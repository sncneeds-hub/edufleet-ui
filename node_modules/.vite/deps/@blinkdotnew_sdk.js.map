{
  "version": 3,
  "sources": ["../../@blinkdotnew/sdk/dist/index.mjs"],
  "sourcesContent": ["var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// ../core/src/types.ts\nvar BlinkError = class extends Error {\n  constructor(message, code, status, details) {\n    super(message);\n    this.code = code;\n    this.status = status;\n    this.details = details;\n    this.name = \"BlinkError\";\n  }\n};\nvar BlinkAuthError = class extends BlinkError {\n  code;\n  retryable;\n  userMessage;\n  constructor(code, message, userMessage, details) {\n    super(message, code, 401, details);\n    this.name = \"BlinkAuthError\";\n    this.code = code;\n    this.retryable = [\"NETWORK_ERROR\", \"RATE_LIMITED\"].includes(code);\n    this.userMessage = userMessage || this.getDefaultUserMessage(code);\n  }\n  getDefaultUserMessage(code) {\n    switch (code) {\n      case \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */:\n        return \"Invalid email or password. Please try again.\";\n      case \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */:\n        return \"Please verify your email address before signing in.\";\n      case \"POPUP_CANCELED\" /* POPUP_CANCELED */:\n        return \"Sign-in was canceled. Please try again.\";\n      case \"NETWORK_ERROR\" /* NETWORK_ERROR */:\n        return \"Network error. Please check your connection and try again.\";\n      case \"RATE_LIMITED\" /* RATE_LIMITED */:\n        return \"Too many attempts. Please wait a moment and try again.\";\n      case \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */:\n        return \"Authentication timed out. Please try again.\";\n      case \"REDIRECT_FAILED\" /* REDIRECT_FAILED */:\n        return \"Redirect failed. Please try again.\";\n      case \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */:\n        return \"Session expired. Please sign in again.\";\n      case \"USER_NOT_FOUND\" /* USER_NOT_FOUND */:\n        return \"User not found. Please check your email and try again.\";\n      case \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */:\n        return \"An account with this email already exists.\";\n      case \"WEAK_PASSWORD\" /* WEAK_PASSWORD */:\n        return \"Password is too weak. Please choose a stronger password.\";\n      case \"INVALID_EMAIL\" /* INVALID_EMAIL */:\n        return \"Please enter a valid email address.\";\n      case \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */:\n        return \"Magic link has expired. Please request a new one.\";\n      case \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */:\n        return \"Verification failed. Please try again.\";\n      default:\n        return \"Authentication error. Please try again.\";\n    }\n  }\n};\nvar BlinkNetworkError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NETWORK_ERROR\", status, details);\n    this.name = \"BlinkNetworkError\";\n  }\n};\nvar BlinkValidationError = class extends BlinkError {\n  constructor(message, details) {\n    super(message, \"VALIDATION_ERROR\", 400, details);\n    this.name = \"BlinkValidationError\";\n  }\n};\nvar BlinkStorageError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"STORAGE_ERROR\", status, details);\n    this.name = \"BlinkStorageError\";\n  }\n};\nvar BlinkAIError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"AI_ERROR\", status, details);\n    this.name = \"BlinkAIError\";\n  }\n};\nvar BlinkDataError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"DATA_ERROR\", status, details);\n    this.name = \"BlinkDataError\";\n  }\n};\nvar BlinkRealtimeError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"REALTIME_ERROR\", status, details);\n    this.name = \"BlinkRealtimeError\";\n  }\n};\nvar BlinkNotificationsError = class extends BlinkError {\n  constructor(message, status, details) {\n    super(message, \"NOTIFICATIONS_ERROR\", status, details);\n    this.name = \"BlinkNotificationsError\";\n  }\n};\n\n// ../core/src/query-builder.ts\nfunction camelToSnake(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction convertFilterKeysToSnakeCase(condition) {\n  if (!condition) return condition;\n  if (\"AND\" in condition) {\n    return {\n      AND: condition.AND?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  if (\"OR\" in condition) {\n    return {\n      OR: condition.OR?.map(convertFilterKeysToSnakeCase)\n    };\n  }\n  const converted = {};\n  for (const [field, value] of Object.entries(condition)) {\n    const snakeField = camelToSnake(field);\n    converted[snakeField] = value;\n  }\n  return converted;\n}\nfunction buildFilterQuery(condition) {\n  if (!condition) return \"\";\n  if (\"AND\" in condition) {\n    const andConditions = condition.AND?.map(buildFilterQuery).filter(Boolean) || [];\n    return andConditions.length > 0 ? `and=(${andConditions.join(\",\")})` : \"\";\n  }\n  if (\"OR\" in condition) {\n    const orConditions = condition.OR?.map(buildFilterQuery).filter(Boolean) || [];\n    return orConditions.length > 0 ? `or=(${orConditions.join(\",\")})` : \"\";\n  }\n  const params = [];\n  for (const [field, value] of Object.entries(condition)) {\n    if (value === void 0 || value === null) continue;\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n      for (const [operator, operatorValue] of Object.entries(value)) {\n        const param = buildOperatorQuery(field, operator, operatorValue);\n        if (param) params.push(param);\n      }\n    } else {\n      params.push(`${field}=eq.${encodeQueryValue(value)}`);\n    }\n  }\n  return params.join(\"&\");\n}\nfunction buildOperatorQuery(field, operator, value) {\n  switch (operator) {\n    case \"eq\":\n      return `${field}=eq.${encodeQueryValue(value)}`;\n    case \"neq\":\n      return `${field}=neq.${encodeQueryValue(value)}`;\n    case \"gt\":\n      return `${field}=gt.${encodeQueryValue(value)}`;\n    case \"gte\":\n      return `${field}=gte.${encodeQueryValue(value)}`;\n    case \"lt\":\n      return `${field}=lt.${encodeQueryValue(value)}`;\n    case \"lte\":\n      return `${field}=lte.${encodeQueryValue(value)}`;\n    case \"like\":\n      return `${field}=like.${encodeQueryValue(value)}`;\n    case \"ilike\":\n      return `${field}=ilike.${encodeQueryValue(value)}`;\n    case \"is\":\n      return `${field}=is.${value === null ? \"null\" : encodeQueryValue(value)}`;\n    case \"not\":\n      return `${field}=not.${encodeQueryValue(value)}`;\n    case \"in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=in.(${values})`;\n      }\n      return \"\";\n    case \"not_in\":\n      if (Array.isArray(value)) {\n        const values = value.map(encodeQueryValue).join(\",\");\n        return `${field}=not.in.(${values})`;\n      }\n      return \"\";\n    default:\n      return \"\";\n  }\n}\nfunction encodeQueryValue(value) {\n  if (value === null) return \"null\";\n  if (typeof value === \"boolean\") {\n    return value ? \"1\" : \"0\";\n  }\n  if (typeof value === \"number\") return value.toString();\n  return encodeURIComponent(String(value));\n}\nfunction buildQuery(options = {}) {\n  const params = {};\n  if (options.select && options.select.length > 0) {\n    const snakeFields = options.select.map(camelToSnake);\n    params.select = snakeFields.join(\",\");\n  } else {\n    params.select = \"*\";\n  }\n  if (options.where) {\n    const convertedWhere = convertFilterKeysToSnakeCase(options.where);\n    const filterQuery = buildFilterQuery(convertedWhere);\n    if (filterQuery) {\n      const filterParams = filterQuery.split(\"&\");\n      for (const param of filterParams) {\n        const [key, value] = param.split(\"=\", 2);\n        if (key && value) {\n          params[key] = value;\n        }\n      }\n    }\n  }\n  if (options.orderBy) {\n    if (typeof options.orderBy === \"string\") {\n      params.order = options.orderBy;\n    } else {\n      const orderClauses = Object.entries(options.orderBy).map(([field, direction]) => `${camelToSnake(field)}.${direction}`);\n      params.order = orderClauses.join(\",\");\n    }\n  }\n  if (options.limit !== void 0) {\n    params.limit = options.limit.toString();\n  }\n  if (options.offset !== void 0) {\n    params.offset = options.offset.toString();\n  }\n  if (options.cursor) {\n    params.cursor = options.cursor;\n  }\n  return params;\n}\n\n// ../core/src/http-client.ts\nfunction camelToSnake2(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction snakeToCamel(str) {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\nfunction convertKeysToSnakeCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToSnakeCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const snakeKey = camelToSnake2(key);\n    converted[snakeKey] = convertKeysToSnakeCase(value);\n  }\n  return converted;\n}\nfunction convertKeysToCamelCase(obj) {\n  if (obj === null || obj === void 0) return obj;\n  if (typeof obj !== \"object\") return obj;\n  if (Array.isArray(obj)) return obj.map(convertKeysToCamelCase);\n  const converted = {};\n  for (const [key, value] of Object.entries(obj)) {\n    const camelKey = snakeToCamel(key);\n    converted[camelKey] = convertKeysToCamelCase(value);\n  }\n  return converted;\n}\nvar HttpClient = class {\n  authUrl = \"https://blink.new\";\n  coreUrl = \"https://core.blink.new\";\n  projectId;\n  getToken;\n  getValidToken;\n  constructor(config, getToken, getValidToken) {\n    this.projectId = config.projectId;\n    this.getToken = getToken;\n    this.getValidToken = getValidToken;\n  }\n  /**\n   * Make an authenticated request to the Blink API\n   */\n  async request(path, options = {}) {\n    const url = this.buildUrl(path, options.searchParams);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      ...options.headers\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const requestInit = {\n      method: options.method || \"GET\",\n      headers,\n      signal: options.signal\n    };\n    if (options.body && options.method !== \"GET\") {\n      requestInit.body = typeof options.body === \"string\" ? options.body : JSON.stringify(options.body);\n    }\n    try {\n      const response = await fetch(url, requestInit);\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Network request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * GET request\n   */\n  async get(path, searchParams) {\n    return this.request(path, { method: \"GET\", searchParams });\n  }\n  /**\n   * POST request\n   */\n  async post(path, body, headers) {\n    return this.request(path, { method: \"POST\", body, headers });\n  }\n  /**\n   * PATCH request\n   */\n  async patch(path, body, headers) {\n    return this.request(path, { method: \"PATCH\", body, headers });\n  }\n  /**\n   * DELETE request\n   */\n  async delete(path, searchParams) {\n    return this.request(path, { method: \"DELETE\", searchParams });\n  }\n  /**\n   * Database-specific requests\n   */\n  // Table operations (PostgREST-compatible)\n  async dbGet(table, searchParams) {\n    const response = await this.get(`/api/db/${this.projectId}/rest/v1/${table}`, searchParams);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPost(table, body, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.post(`/api/db/${this.projectId}/rest/v1/${table}`, convertedBody, headers);\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbPatch(table, body, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const convertedBody = convertKeysToSnakeCase(body);\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"PATCH\",\n      body: convertedBody,\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  async dbDelete(table, searchParams, options = {}) {\n    const headers = {};\n    if (options.returning) {\n      headers.Prefer = \"return=representation\";\n    }\n    const response = await this.request(`/api/db/${this.projectId}/rest/v1/${table}`, {\n      method: \"DELETE\",\n      headers,\n      searchParams\n    });\n    const convertedData = convertKeysToCamelCase(response.data);\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Raw SQL operations\n  async dbSql(query, params) {\n    const response = await this.post(`/api/db/${this.projectId}/sql`, { query, params });\n    const convertedData = {\n      ...response.data,\n      rows: convertKeysToCamelCase(response.data.rows)\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  // Batch SQL operations\n  async dbBatch(statements, mode = \"write\") {\n    const response = await this.post(`/api/db/${this.projectId}/batch`, { statements, mode });\n    const convertedData = {\n      ...response.data,\n      results: response.data.results.map((result) => ({\n        ...result,\n        rows: convertKeysToCamelCase(result.rows)\n      }))\n    };\n    return {\n      ...response,\n      data: convertedData\n    };\n  }\n  /**\n   * Upload file with progress tracking\n   */\n  async uploadFile(path, file, filePath, options = {}) {\n    const url = this.buildUrl(path);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const formData = new FormData();\n    if (file instanceof File) {\n      formData.append(\"file\", file);\n    } else if (file instanceof Blob) {\n      const blobWithType = options.contentType ? new Blob([file], { type: options.contentType }) : file;\n      formData.append(\"file\", blobWithType);\n    } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      const blob = new Blob([file], { type: options.contentType || \"application/octet-stream\" });\n      formData.append(\"file\", blob);\n    } else {\n      throw new BlinkValidationError(\"Unsupported file type\");\n    }\n    formData.append(\"path\", filePath);\n    if (options.upsert !== void 0) {\n      formData.append(\"options\", JSON.stringify({ upsert: options.upsert }));\n    }\n    const headers = {};\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    try {\n      if (typeof XMLHttpRequest !== \"undefined\" && options.onProgress) {\n        return this.uploadWithProgress(url, formData, headers, options.onProgress);\n      }\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: formData\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      const data = await this.parseResponse(response);\n      return {\n        data,\n        status: response.status,\n        headers: response.headers\n      };\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `File upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Upload with progress tracking using XMLHttpRequest\n   */\n  uploadWithProgress(url, formData, headers, onProgress) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          const percent = Math.round(event.loaded / event.total * 100);\n          onProgress(percent);\n        }\n      });\n      xhr.addEventListener(\"load\", async () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const data = JSON.parse(xhr.responseText);\n            resolve({\n              data,\n              status: xhr.status,\n              headers: new Headers()\n              // XMLHttpRequest doesn't provide easy access to response headers\n            });\n          } catch (error) {\n            reject(new BlinkNetworkError(\"Failed to parse response\", xhr.status));\n          }\n        } else {\n          try {\n            const errorData = JSON.parse(xhr.responseText);\n            const message = errorData.error?.message || errorData.message || `HTTP ${xhr.status}`;\n            switch (xhr.status) {\n              case 401:\n                reject(new BlinkAuthError(message, errorData));\n                break;\n              case 400:\n                reject(new BlinkValidationError(message, errorData));\n                break;\n              default:\n                reject(new BlinkNetworkError(message, xhr.status, errorData));\n            }\n          } catch {\n            reject(new BlinkNetworkError(`HTTP ${xhr.status}`, xhr.status));\n          }\n        }\n      });\n      xhr.addEventListener(\"error\", () => {\n        reject(new BlinkNetworkError(\"Network error during file upload\"));\n      });\n      xhr.open(\"POST\", url);\n      Object.entries(headers).forEach(([key, value]) => {\n        xhr.setRequestHeader(key, value);\n      });\n      xhr.send(formData);\n    });\n  }\n  /**\n   * AI-specific requests\n   */\n  async aiText(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/text`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI text generation with Vercel AI SDK data stream format\n   */\n  async streamAiText(prompt, options = {}, onChunk) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/text`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal, ...jsonBody } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      return this.parseDataStream(response.body, onChunk);\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiObject(prompt, options = {}) {\n    const { signal, ...body } = options;\n    const requestBody = { ...body };\n    if (prompt) {\n      requestBody.prompt = prompt;\n    }\n    return this.request(`/api/ai/${this.projectId}/object`, {\n      method: \"POST\",\n      body: requestBody,\n      signal\n    });\n  }\n  /**\n   * Stream AI object generation with Vercel AI SDK data stream format\n   */\n  async streamAiObject(prompt, options = {}, onPartial) {\n    const url = this.buildUrl(`/api/ai/${this.projectId}/object`);\n    const token = this.getValidToken ? await this.getValidToken() : this.getToken();\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const body = {\n      prompt,\n      stream: true,\n      ...options\n    };\n    const { signal: _signal2, ...jsonBody2 } = body;\n    try {\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(jsonBody2),\n        signal: options.signal\n      });\n      if (!response.ok) {\n        await this.handleErrorResponse(response);\n      }\n      if (!response.body) {\n        throw new BlinkNetworkError(\"No response body for streaming\");\n      }\n      return this.parseDataStream(response.body, void 0, onPartial);\n    } catch (error) {\n      if (error instanceof BlinkError) {\n        throw error;\n      }\n      throw new BlinkNetworkError(\n        `Streaming request failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        0,\n        { originalError: error }\n      );\n    }\n  }\n  async aiImage(prompt, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/image`, {\n      method: \"POST\",\n      body: {\n        prompt,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiSpeech(text, options = {}) {\n    const { signal, ...body } = options;\n    return this.request(`/api/ai/${this.projectId}/speech`, {\n      method: \"POST\",\n      body: {\n        text,\n        ...body\n      },\n      signal\n    });\n  }\n  async aiTranscribe(audio, options = {}) {\n    const { signal, ...body } = options;\n    let payloadAudio;\n    if (typeof audio === \"string\" || Array.isArray(audio)) {\n      payloadAudio = audio;\n    } else if (audio instanceof Uint8Array) {\n      payloadAudio = Array.from(audio);\n    } else if (audio instanceof ArrayBuffer) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else if (typeof Buffer !== \"undefined\" && Buffer.isBuffer(audio)) {\n      payloadAudio = Array.from(new Uint8Array(audio));\n    } else {\n      throw new BlinkValidationError(\"Unsupported audio input type\");\n    }\n    return this.request(`/api/ai/${this.projectId}/transcribe`, {\n      method: \"POST\",\n      body: {\n        audio: payloadAudio,\n        ...body\n      },\n      signal\n    });\n  }\n  /**\n   * Data-specific requests\n   */\n  async dataExtractFromUrl(projectId, request) {\n    return this.request(`/api/data/${projectId}/extract-from-url`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataExtractFromBlob(projectId, file, chunking, chunkSize) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    if (chunking !== void 0) {\n      formData.append(\"chunking\", String(chunking));\n    }\n    if (chunkSize !== void 0) {\n      formData.append(\"chunkSize\", String(chunkSize));\n    }\n    return this.request(`/api/data/${projectId}/extract-from-blob`, {\n      method: \"POST\",\n      body: formData\n    });\n  }\n  async dataScrape(projectId, request) {\n    return this.request(`/api/data/${projectId}/scrape`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataScreenshot(projectId, request) {\n    return this.request(`/api/data/${projectId}/screenshot`, {\n      method: \"POST\",\n      body: JSON.stringify(request)\n    });\n  }\n  async dataFetch(projectId, request) {\n    return this.post(`/api/data/${projectId}/fetch`, request);\n  }\n  async dataSearch(projectId, request) {\n    return this.post(`/api/data/${projectId}/search`, request);\n  }\n  /**\n   * Realtime-specific requests\n   */\n  async realtimePublish(projectId, request) {\n    return this.post(`/api/realtime/${projectId}/publish`, request);\n  }\n  async realtimeGetPresence(projectId, channel) {\n    return this.get(`/api/realtime/${projectId}/presence`, { channel });\n  }\n  async realtimeGetMessages(projectId, options) {\n    const { channel, ...searchParams } = options;\n    return this.get(`/api/realtime/${projectId}/messages`, {\n      channel,\n      ...Object.fromEntries(\n        Object.entries(searchParams).filter(([k, v]) => v !== void 0).map(([k, v]) => [k, String(v)])\n      )\n    });\n  }\n  /**\n   * Private helper methods\n   */\n  buildUrl(path, searchParams) {\n    const baseUrl = path.includes(\"/api/auth/\") ? this.authUrl : this.coreUrl;\n    const url = new URL(path, baseUrl);\n    if (searchParams) {\n      Object.entries(searchParams).forEach(([key, value]) => {\n        url.searchParams.set(key, value);\n      });\n    }\n    return url.toString();\n  }\n  async parseResponse(response) {\n    const contentType = response.headers.get(\"content-type\");\n    if (contentType?.includes(\"application/json\")) {\n      return response.json();\n    }\n    if (contentType?.includes(\"text/\")) {\n      return response.text();\n    }\n    return response.blob();\n  }\n  async handleErrorResponse(response) {\n    let errorData;\n    try {\n      const contentType = response.headers.get(\"content-type\");\n      if (contentType?.includes(\"application/json\")) {\n        errorData = await response.json();\n      } else {\n        errorData = { message: await response.text() };\n      }\n    } catch {\n      errorData = { message: \"Unknown error occurred\" };\n    }\n    const message = errorData.error?.message || errorData.message || `HTTP ${response.status}`;\n    errorData.error?.code || errorData.code;\n    switch (response.status) {\n      case 401:\n        throw new BlinkAuthError(message, errorData);\n      case 400:\n        throw new BlinkValidationError(message, errorData);\n      default:\n        throw new BlinkNetworkError(message, response.status, errorData);\n    }\n  }\n  /**\n   * Parse Vercel AI SDK data stream format\n   * Handles text chunks (0:\"text\"), partial objects (2:[...]), and metadata (d:, e:)\n   */\n  async parseDataStream(body, onChunk, onPartial) {\n    const reader = body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = \"\";\n    let finalResult = {};\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split(/\\r?\\n/);\n        buffer = lines.pop() || \"\";\n        for (const line of lines) {\n          if (!line.trim()) continue;\n          try {\n            if (line.startsWith(\"f:\")) {\n              const metadata = JSON.parse(line.slice(2));\n              finalResult.messageId = metadata.messageId;\n            } else if (line.startsWith(\"0:\")) {\n              const textChunk = JSON.parse(line.slice(2));\n              if (onChunk) {\n                onChunk(textChunk);\n              }\n              finalResult.text = (finalResult.text || \"\") + textChunk;\n            } else if (line.startsWith(\"2:\")) {\n              const data = JSON.parse(line.slice(2));\n              if (Array.isArray(data) && data.length > 0) {\n                const item = data[0];\n                if (typeof item === \"string\") {\n                  finalResult.status = item;\n                } else if (typeof item === \"object\") {\n                  if (onPartial) {\n                    onPartial(item);\n                  }\n                  finalResult.object = item;\n                }\n              }\n            } else if (line.startsWith(\"d:\")) {\n              const metadata = JSON.parse(line.slice(2));\n              if (metadata.usage) {\n                finalResult.usage = metadata.usage;\n              }\n              if (metadata.finishReason) {\n                finalResult.finishReason = metadata.finishReason;\n              }\n            } else if (line.startsWith(\"e:\")) {\n              const errorData = JSON.parse(line.slice(2));\n              finalResult.error = errorData;\n            }\n          } catch (error) {\n            console.warn(\"Failed to parse stream line:\", line, error);\n          }\n        }\n      }\n      if (buffer.trim()) {\n        try {\n          if (buffer.startsWith(\"0:\")) {\n            const textChunk = JSON.parse(buffer.slice(2));\n            if (onChunk) {\n              onChunk(textChunk);\n            }\n            finalResult.text = (finalResult.text || \"\") + textChunk;\n          } else if (buffer.startsWith(\"2:\")) {\n            const data = JSON.parse(buffer.slice(2));\n            if (Array.isArray(data) && data.length > 0) {\n              const item = data[0];\n              if (typeof item === \"object\") {\n                if (onPartial) {\n                  onPartial(item);\n                }\n                finalResult.object = item;\n              }\n            }\n          } else if (buffer.startsWith(\"d:\")) {\n            const metadata = JSON.parse(buffer.slice(2));\n            if (metadata.usage) {\n              finalResult.usage = metadata.usage;\n            }\n            if (metadata.finishReason) {\n              finalResult.finishReason = metadata.finishReason;\n            }\n          }\n        } catch (error) {\n          console.warn(\"Failed to parse final buffer:\", buffer, error);\n        }\n      }\n      return finalResult;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n};\n\n// src/auth.ts\nvar BlinkAuth = class {\n  config;\n  authConfig;\n  authState;\n  listeners = /* @__PURE__ */ new Set();\n  authUrl;\n  coreUrl;\n  parentWindowTokens = null;\n  isIframe = false;\n  initializationPromise = null;\n  isInitialized = false;\n  constructor(config) {\n    this.config = config;\n    if (!config.projectId) {\n      throw new Error(\"projectId is required for authentication\");\n    }\n    this.authConfig = {\n      mode: \"managed\",\n      // Default mode\n      authUrl: \"https://blink.new\",\n      coreUrl: \"https://core.blink.new\",\n      ...config.auth\n    };\n    this.authUrl = this.authConfig.authUrl || \"https://blink.new\";\n    this.coreUrl = this.authConfig.coreUrl || \"https://core.blink.new\";\n    if (typeof window !== \"undefined\" && this.authUrl === \"https://blink.new\" && (window.location.hostname === \"localhost\" || window.location.hostname === \"127.0.0.1\")) {\n      console.warn(\"\\u26A0\\uFE0F Using default authUrl in development. Set auth.authUrl to your app origin for headless auth endpoints to work.\");\n    }\n    if (config.authRequired !== void 0 && !config.auth?.mode) {\n      this.authConfig.mode = config.authRequired ? \"managed\" : \"headless\";\n    }\n    this.authState = {\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    };\n    if (typeof window !== \"undefined\") {\n      this.isIframe = window.self !== window.top;\n      this.setupParentWindowListener();\n      this.setupCrossTabSync();\n      this.initializationPromise = this.initialize();\n    } else {\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Generate project-scoped storage key\n   */\n  getStorageKey(suffix) {\n    return `blink_${suffix}_${this.config.projectId}`;\n  }\n  /**\n   * Migrate existing global tokens to project-scoped storage\n   * DISABLED: We don't migrate global blink_tokens anymore because:\n   * 1. Platform uses blink_tokens for platform auth (different user)\n   * 2. Migrating platform tokens would cause project to show wrong user\n   * 3. Projects should always authenticate fresh via their own flow\n   */\n  migrateExistingTokens() {\n  }\n  /**\n   * Wait for authentication initialization to complete\n   */\n  async waitForInitialization() {\n    if (this.isInitialized) return;\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n    }\n  }\n  /**\n   * Setup listener for tokens from parent window\n   */\n  setupParentWindowListener() {\n    if (!this.isIframe) return;\n    window.addEventListener(\"message\", (event) => {\n      if (event.origin !== \"https://blink.new\" && event.origin !== \"http://localhost:3000\" && event.origin !== \"http://localhost:3001\") {\n        return;\n      }\n      if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n        console.log(\"\\u{1F4E5} Received auth tokens from parent window\");\n        const { tokens } = event.data;\n        if (tokens) {\n          this.parentWindowTokens = tokens;\n          this.setTokens(tokens, false).then(() => {\n            console.log(\"\\u2705 Tokens from parent window applied\");\n          }).catch((error) => {\n            console.error(\"Failed to apply parent window tokens:\", error);\n          });\n        }\n      }\n      if (event.data?.type === \"BLINK_AUTH_LOGOUT\") {\n        console.log(\"\\u{1F4E4} Received logout command from parent window\");\n        this.clearTokens();\n      }\n    });\n    if (window.parent !== window) {\n      console.log(\"\\u{1F504} Requesting auth tokens from parent window\");\n      window.parent.postMessage({\n        type: \"BLINK_REQUEST_AUTH_TOKENS\",\n        projectId: this.config.projectId\n      }, \"*\");\n    }\n  }\n  /**\n   * Initialize authentication from stored tokens or URL fragments\n   */\n  async initialize() {\n    console.log(\"\\u{1F680} Initializing Blink Auth...\");\n    this.setLoading(true);\n    try {\n      this.migrateExistingTokens();\n      if (this.isIframe) {\n        console.log(\"\\u{1F50D} Detected iframe environment, waiting for parent tokens...\");\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        if (this.parentWindowTokens) {\n          console.log(\"\\u2705 Using tokens from parent window\");\n          await this.setTokens(this.parentWindowTokens, false);\n          return;\n        }\n      }\n      const tokensFromUrl = this.extractTokensFromUrl();\n      if (tokensFromUrl) {\n        console.log(\"\\u{1F4E5} Found tokens in URL, setting them...\");\n        await this.setTokens(tokensFromUrl, true);\n        this.clearUrlTokens();\n        console.log(\"\\u2705 Auth initialization complete (from URL)\");\n        return;\n      }\n      const storedTokens = this.getStoredTokens();\n      if (storedTokens) {\n        console.log(\"\\u{1F4BE} Found stored tokens, validating...\", {\n          hasAccessToken: !!storedTokens.access_token,\n          hasRefreshToken: !!storedTokens.refresh_token,\n          issuedAt: storedTokens.issued_at,\n          expiresIn: storedTokens.expires_in,\n          refreshExpiresIn: storedTokens.refresh_expires_in,\n          currentTime: Math.floor(Date.now() / 1e3)\n        });\n        this.authState.tokens = storedTokens;\n        console.log(\"\\u{1F527} Tokens set in auth state, refresh token available:\", !!this.authState.tokens?.refresh_token);\n        const isValid = await this.validateStoredTokens(storedTokens);\n        if (isValid) {\n          console.log(\"\\u2705 Auth initialization complete (from storage)\");\n          return;\n        } else {\n          console.log(\"\\u{1F504} Stored tokens invalid, clearing...\");\n          this.clearTokens();\n        }\n      }\n      console.log(\"\\u274C No tokens found\");\n      if (this.config.authRequired) {\n        console.log(\"\\u{1F504} Auth required, redirecting to auth page...\");\n        this.redirectToAuth();\n      } else {\n        console.log(\"\\u26A0\\uFE0F Auth not required, continuing without authentication\");\n      }\n    } finally {\n      this.setLoading(false);\n      this.isInitialized = true;\n    }\n  }\n  /**\n   * Redirect to Blink auth page\n   */\n  login(nextUrl) {\n    let redirectUrl = nextUrl || this.authConfig.redirectUrl;\n    if (!redirectUrl && typeof window !== \"undefined\") {\n      if (window.location.href.startsWith(\"http\")) {\n        redirectUrl = window.location.href;\n      } else {\n        redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;\n      }\n    }\n    if (redirectUrl && typeof window !== \"undefined\") {\n      try {\n        const url = new URL(redirectUrl);\n        url.searchParams.delete(\"redirect_url\");\n        url.searchParams.delete(\"redirect\");\n        redirectUrl = url.toString();\n      } catch (e) {\n        console.warn(\"Failed to parse redirect URL:\", e);\n      }\n    }\n    const authUrl = new URL(\"/auth\", this.authUrl);\n    authUrl.searchParams.set(\"redirect_url\", redirectUrl || \"\");\n    if (this.config.projectId) {\n      authUrl.searchParams.set(\"project_id\", this.config.projectId);\n    }\n    if (typeof window !== \"undefined\") {\n      window.location.href = authUrl.toString();\n    }\n  }\n  /**\n   * Logout and clear stored tokens\n   */\n  logout(redirectUrl) {\n    this.clearTokens();\n    if (redirectUrl && typeof window !== \"undefined\") {\n      window.location.href = redirectUrl;\n    }\n  }\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return this.authState.isAuthenticated;\n  }\n  /**\n   * Get current user (sync)\n   */\n  currentUser() {\n    return this.authState.user;\n  }\n  /**\n   * Get current access token\n   */\n  getToken() {\n    return this.authState.tokens?.access_token || null;\n  }\n  /**\n   * Check if access token is expired based on timestamp\n   */\n  isAccessTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.issued_at) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.expires_in;\n    const bufferTime = 30;\n    return now >= expiresAt - bufferTime;\n  }\n  /**\n   * Check if refresh token is expired based on timestamp\n   */\n  isRefreshTokenExpired() {\n    const tokens = this.authState.tokens;\n    if (!tokens || !tokens.refresh_token || !tokens.issued_at || !tokens.refresh_expires_in) {\n      return true;\n    }\n    const now = Math.floor(Date.now() / 1e3);\n    const expiresAt = tokens.issued_at + tokens.refresh_expires_in;\n    return now >= expiresAt;\n  }\n  /**\n   * Get a valid access token, refreshing if necessary\n   */\n  async getValidToken() {\n    const tokens = this.authState.tokens;\n    if (!tokens) {\n      return null;\n    }\n    if (!this.isAccessTokenExpired()) {\n      console.log(\"\\u2705 Access token is still valid\");\n      return tokens.access_token;\n    }\n    console.log(\"\\u23F0 Access token expired, attempting refresh...\");\n    if (this.isRefreshTokenExpired()) {\n      console.log(\"\\u274C Refresh token also expired, clearing tokens\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n    const refreshed = await this.refreshToken();\n    if (refreshed) {\n      console.log(\"\\u2705 Token refreshed successfully\");\n      return this.authState.tokens?.access_token || null;\n    } else {\n      console.log(\"\\u274C Token refresh failed\");\n      this.clearTokens();\n      if (this.config.authRequired) {\n        this.redirectToAuth();\n      }\n      return null;\n    }\n  }\n  /**\n   * Fetch current user profile from API\n   * Gracefully waits for auth initialization to complete before throwing errors\n   */\n  async me() {\n    await this.waitForInitialization();\n    if (this.authState.isAuthenticated && this.authState.user) {\n      return this.authState.user;\n    }\n    if (!this.authState.isAuthenticated) {\n      return new Promise((resolve, reject) => {\n        if (this.authState.user) {\n          resolve(this.authState.user);\n          return;\n        }\n        const timeout = setTimeout(() => {\n          unsubscribe();\n          reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timeout - no user available\"));\n        }, 5e3);\n        const unsubscribe = this.onAuthStateChanged((state) => {\n          if (state.user) {\n            clearTimeout(timeout);\n            unsubscribe();\n            resolve(state.user);\n          } else if (!state.isLoading && !state.isAuthenticated) {\n            clearTimeout(timeout);\n            unsubscribe();\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Not authenticated\"));\n          }\n        });\n      });\n    }\n    let token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${token}`\n        }\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          const refreshed = await this.refreshToken();\n          if (refreshed) {\n            token = this.getToken();\n            if (token) {\n              const retryResponse = await fetch(`${this.authUrl}/api/auth/me`, {\n                headers: {\n                  \"Authorization\": `Bearer ${token}`\n                }\n              });\n              if (retryResponse.ok) {\n                const retryData = await retryResponse.json();\n                const user2 = retryData.user;\n                this.updateAuthState({\n                  ...this.authState,\n                  user: user2\n                });\n                return user2;\n              }\n            }\n          }\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to fetch user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign up with email and password (headless mode)\n   */\n  async signUp(data) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signUp is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signup`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          ...data,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign up failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with email and password (headless mode)\n   */\n  async signInWithEmail(email, password) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithEmail is only available in headless mode\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/email`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          password,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Sign in failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Sign in with Google (headless mode)\n   */\n  async signInWithGoogle(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGoogle is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"google\", options);\n  }\n  /**\n   * Sign in with GitHub (headless mode)\n   */\n  async signInWithGitHub(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithGitHub is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"github\", options);\n  }\n  /**\n   * Sign in with Apple (headless mode)\n   */\n  async signInWithApple(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithApple is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"apple\", options);\n  }\n  /**\n   * Sign in with Microsoft (headless mode)\n   */\n  async signInWithMicrosoft(options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithMicrosoft is only available in headless mode\");\n    }\n    return this.signInWithProvider(\"microsoft\", options);\n  }\n  /**\n   * Generic provider sign-in method (headless mode)\n   */\n  async signInWithProvider(provider, options) {\n    if (this.authConfig.mode !== \"headless\") {\n      throw new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"signInWithProvider is only available in headless mode\");\n    }\n    return new Promise((resolve, reject) => {\n      const state = this.generateState();\n      try {\n        if (typeof window !== \"undefined\") {\n          sessionStorage.setItem(\"blink_oauth_state\", state);\n        }\n      } catch {\n      }\n      const redirectUrl = options?.redirectUrl || window.location.origin;\n      const popupUrl = new URL(\"/auth\", this.authUrl);\n      popupUrl.searchParams.set(\"provider\", provider);\n      popupUrl.searchParams.set(\"project_id\", this.config.projectId);\n      popupUrl.searchParams.set(\"state\", state);\n      popupUrl.searchParams.set(\"mode\", \"popup\");\n      popupUrl.searchParams.set(\"redirect_url\", redirectUrl);\n      const popup = window.open(\n        popupUrl.toString(),\n        \"blink-auth\",\n        \"width=500,height=600,scrollbars=yes,resizable=yes\"\n      );\n      if (!popup) {\n        reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Popup was blocked\"));\n        return;\n      }\n      let timeoutId;\n      const messageListener = (event) => {\n        let allowed = false;\n        try {\n          const authOrigin = new URL(this.authUrl).origin;\n          if (event.origin === authOrigin) allowed = true;\n        } catch {\n        }\n        if (event.origin === \"http://localhost:3000\" || event.origin === \"http://localhost:3001\") allowed = true;\n        if (!allowed) return;\n        if (event.data?.type === \"BLINK_AUTH_TOKENS\") {\n          const { access_token, refresh_token, token_type, expires_in, refresh_expires_in, projectId, state: returnedState } = event.data;\n          try {\n            const expected = sessionStorage.getItem(\"blink_oauth_state\");\n            if (returnedState && expected && returnedState !== expected) {\n              reject(new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"State mismatch\"));\n              clearTimeout(timeoutId);\n              window.removeEventListener(\"message\", messageListener);\n              popup.close();\n              return;\n            }\n          } catch {\n          }\n          if (projectId !== this.config.projectId) {\n            reject(new BlinkAuthError(\"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */, \"Project ID mismatch\"));\n            return;\n          }\n          this.setTokens({\n            access_token,\n            refresh_token,\n            token_type,\n            expires_in,\n            refresh_expires_in\n          }, true).then(() => {\n            resolve(this.authState.user);\n          }).catch(reject);\n          clearTimeout(timeoutId);\n          window.removeEventListener(\"message\", messageListener);\n          popup.close();\n        } else if (event.data?.type === \"BLINK_AUTH_ERROR\") {\n          const errorCode = this.mapErrorCodeFromResponse(event.data.code);\n          reject(new BlinkAuthError(errorCode, event.data.message || \"Authentication failed\"));\n          clearTimeout(timeoutId);\n          window.removeEventListener(\"message\", messageListener);\n          popup.close();\n        }\n      };\n      timeoutId = setTimeout(() => {\n        window.removeEventListener(\"message\", messageListener);\n        if (!popup.closed) {\n          popup.close();\n        }\n        reject(new BlinkAuthError(\"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */, \"Authentication timed out\"));\n      }, 3e5);\n      const checkClosed = setInterval(() => {\n        if (popup.closed) {\n          clearInterval(checkClosed);\n          clearTimeout(timeoutId);\n          window.removeEventListener(\"message\", messageListener);\n          reject(new BlinkAuthError(\"POPUP_CANCELED\" /* POPUP_CANCELED */, \"Authentication was canceled\"));\n        }\n      }, 1e3);\n      window.addEventListener(\"message\", messageListener);\n    });\n  }\n  /**\n   * Generate password reset token (for custom email delivery)\n   */\n  async generatePasswordResetToken(email) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate password reset token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate password reset token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send password reset email (using Blink default email service)\n   */\n  async sendPasswordResetEmail(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          projectId: this.config.projectId,\n          redirectUrl: options?.redirectUrl\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send password reset email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Confirm password reset with token\n   */\n  async confirmPasswordReset(token, newPassword) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/reset/confirm`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          password: newPassword,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to reset password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Change password (requires current authentication)\n   */\n  async changePassword(oldPassword, newPassword) {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/password/change`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          oldPassword,\n          newPassword\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to change password\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate email verification token (for custom email delivery)\n   */\n  async generateEmailVerificationToken() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate email verification token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate email verification token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send email verification (using Blink default email service)\n   */\n  async sendEmailVerification() {\n    const token = await this.getValidToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify/send`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send verification email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify email with token\n   */\n  async verifyEmail(token) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/email/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to verify email\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Generate magic link token (for custom email delivery)\n   */\n  async generateMagicLinkToken(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/generate`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(\n          errorCode,\n          errorData.error || \"Failed to generate magic link token\",\n          errorData.error\n        );\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\n        \"NETWORK_ERROR\" /* NETWORK_ERROR */,\n        \"Failed to generate magic link token\",\n        \"Network error occurred\"\n      );\n    }\n  }\n  /**\n   * Send magic link (using Blink default email service)\n   */\n  async sendMagicLink(email, options) {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          email,\n          redirectUrl: options?.redirectUrl,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Failed to send magic link\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Verify magic link (automatic on redirect)\n   */\n  async verifyMagicLink(token) {\n    const magicToken = token || this.extractMagicTokenFromUrl();\n    if (!magicToken) {\n      throw new BlinkAuthError(\"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */, \"No magic link token found\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/signin/magic/verify`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          token: magicToken,\n          projectId: this.config.projectId\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || \"Magic link verification failed\");\n      }\n      const result = await response.json();\n      await this.setTokens({\n        access_token: result.access_token,\n        refresh_token: result.refresh_token,\n        token_type: result.token_type,\n        expires_in: result.expires_in,\n        refresh_expires_in: result.refresh_expires_in\n      }, true);\n      return result.user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Get available providers for the current project\n   */\n  async getAvailableProviders() {\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/providers?projectId=${encodeURIComponent(this.config.projectId)}`);\n      if (!response.ok) {\n        return [\"email\", \"google\"];\n      }\n      const data = await response.json();\n      return data.providers || [\"email\", \"google\"];\n    } catch (error) {\n      return [\"email\", \"google\"];\n    }\n  }\n  /**\n   * Check if user has a specific role\n   */\n  hasRole(role) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    if (Array.isArray(role)) {\n      return role.includes(user.role);\n    }\n    return user.role === role;\n  }\n  /**\n   * Check if user can perform a specific action\n   */\n  can(permission, resource) {\n    const user = this.authState.user;\n    if (!user || !user.role) {\n      return false;\n    }\n    const roles = this.authConfig.roles;\n    if (!roles) {\n      return false;\n    }\n    const roleConfig = roles[user.role];\n    if (!roleConfig) {\n      return false;\n    }\n    if (roleConfig.permissions.includes(\"*\")) {\n      return true;\n    }\n    const fullPermission = resource ? `${permission}.${resource}` : permission;\n    if (roleConfig.permissions.includes(fullPermission)) {\n      return true;\n    }\n    if (roleConfig.permissions.includes(permission)) {\n      return true;\n    }\n    const visited = /* @__PURE__ */ new Set();\n    const hasPermissionInRole = (roleName) => {\n      if (visited.has(roleName)) return false;\n      visited.add(roleName);\n      const rc = roles[roleName];\n      if (!rc) return false;\n      if (rc.permissions.includes(\"*\")) return true;\n      const fullPermission2 = resource ? `${permission}.${resource}` : permission;\n      if (rc.permissions.includes(fullPermission2) || rc.permissions.includes(permission)) return true;\n      if (rc.inherit) {\n        for (const parent of rc.inherit) {\n          if (hasPermissionInRole(parent)) return true;\n        }\n      }\n      return false;\n    };\n    if (hasPermissionInRole(user.role)) return true;\n    return false;\n  }\n  /**\n   * Sign out (clear local tokens)\n   * Note: With stateless tokens, this only clears local storage\n   */\n  async signOut() {\n    this.clearTokens();\n  }\n  /**\n   * @deprecated Use signOut() instead. Kept for backward compatibility.\n   */\n  async revokeAllSessions() {\n    return this.signOut();\n  }\n  /**\n   * Recover auth state (clear corrupted tokens and re-initialize)\n   */\n  async recoverAuthState() {\n    console.log(\"\\u{1F504} Recovering auth state...\");\n    this.clearTokens();\n    this.isInitialized = false;\n    this.initializationPromise = null;\n    if (typeof window !== \"undefined\") {\n      this.initializationPromise = this.initialize();\n      await this.initializationPromise;\n    }\n    console.log(\"\\u2705 Auth state recovery complete\");\n  }\n  /**\n   * Update user profile\n   */\n  async updateMe(updates) {\n    const token = this.getToken();\n    if (!token) {\n      throw new BlinkAuthError(\"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */, \"No access token available\");\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        method: \"PATCH\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(updates)\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        const errorCode = this.mapErrorCodeFromResponse(errorData.code);\n        throw new BlinkAuthError(errorCode, errorData.error || `Failed to update user: ${response.statusText}`);\n      }\n      const data = await response.json();\n      const user = data.user;\n      this.updateAuthState({\n        ...this.authState,\n        user\n      });\n      return user;\n    } catch (error) {\n      if (error instanceof BlinkAuthError) {\n        throw error;\n      }\n      throw new BlinkAuthError(\"NETWORK_ERROR\" /* NETWORK_ERROR */, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n  }\n  /**\n   * Manually set tokens (for server-side usage)\n   */\n  async setToken(jwt, persist = false) {\n    const tokens = {\n      access_token: jwt,\n      token_type: \"Bearer\",\n      expires_in: 15 * 60\n      // Default 15 minutes\n    };\n    await this.setTokens(tokens, persist);\n  }\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshToken() {\n    const refreshToken = this.authState.tokens?.refresh_token;\n    if (!refreshToken) {\n      return false;\n    }\n    try {\n      const response = await fetch(`${this.authUrl}/api/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          refresh_token: refreshToken\n        })\n      });\n      if (!response.ok) {\n        if (response.status === 401) {\n          this.clearTokens();\n          if (this.config.authRequired) {\n            this.redirectToAuth();\n          }\n        }\n        return false;\n      }\n      const data = await response.json();\n      await this.setTokens({\n        access_token: data.access_token,\n        refresh_token: data.refresh_token,\n        token_type: data.token_type,\n        expires_in: data.expires_in,\n        refresh_expires_in: data.refresh_expires_in\n      }, true);\n      return true;\n    } catch (error) {\n      console.error(\"Token refresh failed:\", error);\n      return false;\n    }\n  }\n  /**\n   * Add auth state change listener\n   */\n  onAuthStateChanged(callback) {\n    this.listeners.add(callback);\n    queueMicrotask(() => {\n      try {\n        callback(this.authState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n  /**\n   * Private helper methods\n   */\n  async validateStoredTokens(tokens) {\n    try {\n      console.log(\"\\u{1F50D} Validating stored tokens...\");\n      if (this.isAccessTokenExpired()) {\n        console.log(\"\\u23F0 Access token expired based on timestamp, attempting refresh...\");\n        if (!tokens.refresh_token) {\n          console.log(\"\\u274C No refresh token available\");\n          return false;\n        }\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token also expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully during validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed during validation\");\n          return false;\n        }\n      }\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokens.access_token}`\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const user = data.user;\n        this.updateAuthState({\n          user,\n          tokens,\n          isAuthenticated: true,\n          isLoading: false\n        });\n        console.log(\"\\u2705 Stored tokens are valid, user authenticated\");\n        return true;\n      } else if (response.status === 401 && tokens.refresh_token) {\n        console.log(\"\\u{1F504} Access token expired (server validation), attempting refresh...\");\n        if (this.isRefreshTokenExpired()) {\n          console.log(\"\\u274C Refresh token expired\");\n          return false;\n        }\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          console.log(\"\\u2705 Token refreshed successfully after server validation\");\n          return true;\n        } else {\n          console.log(\"\\u274C Token refresh failed after server validation\");\n          return false;\n        }\n      } else {\n        console.log(\"\\u274C Token validation failed:\", response.status, response.statusText);\n        return false;\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error validating tokens:\", error);\n      return false;\n    }\n  }\n  async setTokens(tokens, persist) {\n    const tokensWithTimestamp = {\n      ...tokens,\n      issued_at: tokens.issued_at || Math.floor(Date.now() / 1e3)\n    };\n    console.log(\"\\u{1F510} Setting tokens:\", {\n      persist,\n      hasAccessToken: !!tokensWithTimestamp.access_token,\n      hasRefreshToken: !!tokensWithTimestamp.refresh_token,\n      expiresIn: tokensWithTimestamp.expires_in,\n      issuedAt: tokensWithTimestamp.issued_at\n    });\n    if (persist && typeof window !== \"undefined\") {\n      try {\n        localStorage.setItem(this.getStorageKey(\"tokens\"), JSON.stringify(tokensWithTimestamp));\n        console.log(\"\\u{1F4BE} Tokens persisted to localStorage\");\n      } catch (error) {\n        console.log(\"\\u{1F4A5} Error persisting tokens to localStorage:\", error);\n        if (error instanceof DOMException && error.name === \"SecurityError\") {\n          console.log(\"\\u{1F6AB} localStorage access blocked - running in cross-origin iframe\");\n        }\n      }\n    }\n    let user = null;\n    try {\n      console.log(\"\\u{1F464} Fetching user data...\");\n      const response = await fetch(`${this.authUrl}/api/auth/me`, {\n        headers: {\n          \"Authorization\": `Bearer ${tokensWithTimestamp.access_token}`\n        }\n      });\n      console.log(\"\\u{1F4E1} User fetch response:\", {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok\n      });\n      if (response.ok) {\n        const data = await response.json();\n        user = data.user;\n        console.log(\"\\u2705 User data fetched successfully:\", {\n          id: user?.id,\n          email: user?.email,\n          displayName: user?.displayName\n        });\n      } else {\n        console.log(\"\\u274C Failed to fetch user data:\", await response.text());\n      }\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error fetching user data:\", error);\n    }\n    this.updateAuthState({\n      user,\n      tokens: tokensWithTimestamp,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n    console.log(\"\\u{1F3AF} Auth state updated:\", {\n      hasUser: !!user,\n      isAuthenticated: !!user,\n      isLoading: false\n    });\n  }\n  clearTokens() {\n    if (typeof window !== \"undefined\") {\n      try {\n        localStorage.removeItem(this.getStorageKey(\"tokens\"));\n      } catch (error) {\n        console.log(\"\\u{1F4A5} Error clearing tokens from localStorage:\", error);\n      }\n    }\n    this.updateAuthState({\n      user: null,\n      tokens: null,\n      isAuthenticated: false,\n      isLoading: false\n    });\n  }\n  getStoredTokens() {\n    if (typeof window === \"undefined\") return null;\n    if (this.isIframe && this.parentWindowTokens) {\n      return this.parentWindowTokens;\n    }\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"tokens\"));\n      console.log(\"\\u{1F50D} Checking localStorage for tokens:\", {\n        hasStoredData: !!stored,\n        storedLength: stored?.length || 0,\n        origin: window.location.origin,\n        isIframe: window.self !== window.top\n      });\n      if (stored) {\n        const tokens = JSON.parse(stored);\n        console.log(\"\\u{1F4E6} Parsed stored tokens:\", {\n          hasAccessToken: !!tokens.access_token,\n          hasRefreshToken: !!tokens.refresh_token,\n          tokenType: tokens.token_type,\n          expiresIn: tokens.expires_in\n        });\n        return tokens;\n      }\n      return null;\n    } catch (error) {\n      console.log(\"\\u{1F4A5} Error accessing localStorage:\", error);\n      if (error instanceof DOMException && error.name === \"SecurityError\") {\n        console.log(\"\\u{1F6AB} localStorage access blocked - likely due to cross-origin iframe restrictions\");\n      }\n      return null;\n    }\n  }\n  extractTokensFromUrl() {\n    if (typeof window === \"undefined\") return null;\n    const params = new URLSearchParams(window.location.search);\n    const accessToken = params.get(\"access_token\");\n    const refreshToken = params.get(\"refresh_token\");\n    console.log(\"\\u{1F50D} Extracting tokens from URL:\", {\n      url: window.location.href,\n      accessToken: accessToken ? `${accessToken.substring(0, 20)}...` : null,\n      refreshToken: refreshToken ? `${refreshToken.substring(0, 20)}...` : null,\n      allParams: Object.fromEntries(params.entries())\n    });\n    if (accessToken) {\n      const tokens = {\n        access_token: accessToken,\n        refresh_token: refreshToken || void 0,\n        token_type: \"Bearer\",\n        expires_in: 15 * 60,\n        // 15 minutes default\n        refresh_expires_in: refreshToken ? 30 * 24 * 60 * 60 : void 0,\n        // 30 days default\n        issued_at: Math.floor(Date.now() / 1e3)\n        // Current timestamp\n      };\n      console.log(\"\\u2705 Tokens extracted successfully:\", {\n        hasAccessToken: !!tokens.access_token,\n        hasRefreshToken: !!tokens.refresh_token\n      });\n      return tokens;\n    }\n    console.log(\"\\u274C No access token found in URL\");\n    return null;\n  }\n  clearUrlTokens() {\n    if (typeof window === \"undefined\") return;\n    const url = new URL(window.location.href);\n    url.searchParams.delete(\"access_token\");\n    url.searchParams.delete(\"refresh_token\");\n    url.searchParams.delete(\"token_type\");\n    url.searchParams.delete(\"project_id\");\n    url.searchParams.delete(\"expires_in\");\n    url.searchParams.delete(\"refresh_expires_in\");\n    url.searchParams.delete(\"state\");\n    url.searchParams.delete(\"code\");\n    url.searchParams.delete(\"error\");\n    url.searchParams.delete(\"error_description\");\n    window.history.replaceState({}, \"\", url.toString());\n    console.log(\"\\u{1F9F9} URL cleaned up, removed auth parameters\");\n  }\n  redirectToAuth() {\n    if (typeof window !== \"undefined\") {\n      this.login();\n    }\n  }\n  setLoading(loading) {\n    this.updateAuthState({\n      ...this.authState,\n      isLoading: loading\n    });\n  }\n  updateAuthState(newState) {\n    this.authState = newState;\n    this.listeners.forEach((callback) => {\n      try {\n        callback(newState);\n      } catch (error) {\n        console.error(\"Error in auth state change callback:\", error);\n      }\n    });\n  }\n  /**\n   * Generate secure random state for OAuth flows\n   */\n  generateState() {\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      const array = new Uint8Array(16);\n      crypto.getRandomValues(array);\n      return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n    } else {\n      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n    }\n  }\n  /**\n   * Extract magic link token from URL\n   */\n  extractMagicTokenFromUrl() {\n    if (typeof window === \"undefined\") return null;\n    const params = new URLSearchParams(window.location.search);\n    return params.get(\"magic_token\") || params.get(\"token\");\n  }\n  /**\n   * Map server error codes to BlinkAuthErrorCode\n   */\n  mapErrorCodeFromResponse(serverCode) {\n    switch (serverCode) {\n      case \"INVALID_CREDENTIALS\":\n      case \"auth/invalid-credential\":\n      case \"auth/wrong-password\":\n      case \"auth/user-not-found\":\n        return \"INVALID_CREDENTIALS\" /* INVALID_CREDENTIALS */;\n      case \"EMAIL_NOT_VERIFIED\":\n      case \"auth/email-not-verified\":\n        return \"EMAIL_NOT_VERIFIED\" /* EMAIL_NOT_VERIFIED */;\n      case \"EMAIL_ALREADY_VERIFIED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      case \"POPUP_CANCELED\":\n      case \"auth/popup-closed-by-user\":\n        return \"POPUP_CANCELED\" /* POPUP_CANCELED */;\n      case \"NETWORK_ERROR\":\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n      case \"RATE_LIMITED\":\n      case \"auth/too-many-requests\":\n        return \"RATE_LIMITED\" /* RATE_LIMITED */;\n      case \"AUTH_TIMEOUT\":\n        return \"AUTH_TIMEOUT\" /* AUTH_TIMEOUT */;\n      case \"REDIRECT_FAILED\":\n        return \"REDIRECT_FAILED\" /* REDIRECT_FAILED */;\n      case \"TOKEN_EXPIRED\":\n      case \"auth/id-token-expired\":\n        return \"TOKEN_EXPIRED\" /* TOKEN_EXPIRED */;\n      case \"USER_NOT_FOUND\":\n        return \"USER_NOT_FOUND\" /* USER_NOT_FOUND */;\n      case \"EMAIL_ALREADY_EXISTS\":\n      case \"auth/email-already-in-use\":\n        return \"EMAIL_ALREADY_EXISTS\" /* EMAIL_ALREADY_EXISTS */;\n      case \"WEAK_PASSWORD\":\n      case \"auth/weak-password\":\n        return \"WEAK_PASSWORD\" /* WEAK_PASSWORD */;\n      case \"INVALID_EMAIL\":\n      case \"auth/invalid-email\":\n        return \"INVALID_EMAIL\" /* INVALID_EMAIL */;\n      case \"MAGIC_LINK_EXPIRED\":\n        return \"MAGIC_LINK_EXPIRED\" /* MAGIC_LINK_EXPIRED */;\n      case \"VERIFICATION_FAILED\":\n        return \"VERIFICATION_FAILED\" /* VERIFICATION_FAILED */;\n      default:\n        return \"NETWORK_ERROR\" /* NETWORK_ERROR */;\n    }\n  }\n  /**\n   * Setup cross-tab authentication synchronization\n   */\n  setupCrossTabSync() {\n    if (typeof window === \"undefined\") return;\n    window.addEventListener(\"storage\", (e) => {\n      if (e.key === this.getStorageKey(\"tokens\")) {\n        const newTokens = e.newValue ? JSON.parse(e.newValue) : null;\n        if (newTokens && newTokens !== this.authState.tokens) {\n          this.setTokens(newTokens, false).catch((error) => {\n            console.error(\"Failed to sync tokens from other tab:\", error);\n          });\n        } else if (!newTokens && this.authState.tokens) {\n          this.clearTokens();\n        }\n      }\n    });\n  }\n};\n\n// src/database.ts\nfunction camelToSnake3(str) {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\nfunction generateSecureId() {\n  if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n    const array = new Uint8Array(16);\n    crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  } else {\n    const timestamp = Date.now().toString(36);\n    const randomPart = Math.random().toString(36).substring(2, 15);\n    const extraRandom = Math.random().toString(36).substring(2, 15);\n    return `${timestamp}_${randomPart}_${extraRandom}`;\n  }\n}\nfunction ensureRecordId(record) {\n  if (!record.id) {\n    return { ...record, id: generateSecureId() };\n  }\n  return record;\n}\nvar BlinkTable = class {\n  constructor(tableName, httpClient) {\n    this.tableName = tableName;\n    this.httpClient = httpClient;\n    this.actualTableName = camelToSnake3(tableName);\n  }\n  actualTableName;\n  /**\n   * Create a single record\n   */\n  async create(data, options = {}) {\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      record,\n      { returning: options.returning !== false }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to create record\");\n    }\n    return result;\n  }\n  /**\n   * Create multiple records\n   */\n  async createMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const response = await this.httpClient.dbPost(\n      this.actualTableName,\n      records,\n      { returning: options.returning !== false }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Upsert a single record (insert or update on conflict)\n   */\n  async upsert(data, options = {}) {\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const record = ensureRecordId(data);\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: record,\n        headers\n      }\n    );\n    const result = Array.isArray(response.data) ? response.data[0] : response.data;\n    if (!result) {\n      throw new Error(\"Failed to upsert record\");\n    }\n    return result;\n  }\n  /**\n   * Upsert multiple records\n   */\n  async upsertMany(data, options = {}) {\n    const records = data.map(ensureRecordId);\n    const headers = {};\n    if (options.returning !== false) {\n      headers.Prefer = \"return=representation\";\n    }\n    if (options.onConflict) {\n      headers[\"Prefer\"] = `${headers[\"Prefer\"] || \"\"} resolution=merge-duplicates`.trim();\n    }\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}?on_conflict=${options.onConflict || \"id\"}`,\n      {\n        method: \"POST\",\n        body: records,\n        headers\n      }\n    );\n    const results = Array.isArray(response.data) ? response.data : [response.data];\n    return results;\n  }\n  /**\n   * Get a single record by ID\n   */\n  async get(id) {\n    const searchParams = {\n      id: `eq.${id}`,\n      limit: \"1\"\n    };\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    if (records.length === 0) {\n      return null;\n    }\n    return records[0] || null;\n  }\n  /**\n   * List records with filtering, sorting, and pagination\n   */\n  async list(options = {}) {\n    const queryParams = buildQuery(options);\n    const searchParams = queryParams;\n    const response = await this.httpClient.dbGet(this.actualTableName, searchParams);\n    const records = response.data;\n    return records;\n  }\n  /**\n   * Update a single record by ID\n   */\n  async update(id, data, options = {}) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    const response = await this.httpClient.dbPatch(\n      this.actualTableName,\n      data,\n      searchParams,\n      { returning: options.returning !== false }\n    );\n    const records = response.data;\n    if (!records || records.length === 0) {\n      throw new Error(`Record with id ${id} not found`);\n    }\n    return records[0];\n  }\n  /**\n   * Update multiple records\n   */\n  async updateMany(updates, options = {}) {\n    const results = [];\n    for (const update of updates) {\n      const { id, ...data } = update;\n      const result = await this.update(id, data, options);\n      results.push(result);\n    }\n    return results;\n  }\n  /**\n   * Delete a single record by ID\n   */\n  async delete(id) {\n    const searchParams = {\n      id: `eq.${id}`\n    };\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Delete multiple records based on filter\n   */\n  async deleteMany(options) {\n    const queryParams = buildQuery({ where: options.where });\n    const searchParams = queryParams;\n    await this.httpClient.dbDelete(this.actualTableName, searchParams);\n  }\n  /**\n   * Count records matching filter\n   */\n  async count(options = {}) {\n    const queryParams = buildQuery({\n      where: options.where,\n      select: [\"id\"]\n    });\n    const response = await this.httpClient.request(\n      `/api/db/${this.httpClient.projectId}/rest/v1/${this.actualTableName}`,\n      {\n        method: \"GET\",\n        searchParams: queryParams,\n        headers: {\n          \"Prefer\": \"count=exact\"\n        }\n      }\n    );\n    const contentRange = response.headers.get(\"content-range\");\n    if (contentRange) {\n      const match = contentRange.match(/\\/(\\d+)$/);\n      if (match && match[1]) {\n        return parseInt(match[1], 10);\n      }\n    }\n    const records = response.data;\n    return records.length;\n  }\n  /**\n   * Check if any records exist matching filter\n   */\n  async exists(options) {\n    const count = await this.count(options);\n    return count > 0;\n  }\n  /**\n   * Raw SQL query on this table (for advanced use cases)\n   */\n  async sql(query, params) {\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Private helper methods\n   */\n  extractCursor(record) {\n    return record.id || record._id || String(Math.random());\n  }\n};\nvar BlinkDatabase = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    const proxy = new Proxy(this, {\n      get(target, prop) {\n        if (prop === \"table\") {\n          return target.table.bind(target);\n        }\n        if (prop in target) {\n          const value = target[prop];\n          return typeof value === \"function\" ? value.bind(target) : value;\n        }\n        if (typeof prop === \"string\") {\n          return target.table(prop);\n        }\n        return void 0;\n      }\n    });\n    return proxy;\n  }\n  tables = /* @__PURE__ */ new Map();\n  /**\n   * Get a table instance for any table name\n   */\n  table(tableName) {\n    if (!this.tables.has(tableName)) {\n      this.tables.set(tableName, new BlinkTable(tableName, this.httpClient));\n    }\n    const table = this.tables.get(tableName);\n    if (!table) {\n      throw new Error(`Table ${tableName} not found`);\n    }\n    return table;\n  }\n  /**\n   * Execute raw SQL query\n   */\n  async sql(query, params) {\n    const response = await this.httpClient.dbSql(query, params);\n    return response.data;\n  }\n  /**\n   * Execute batch SQL operations\n   */\n  async batch(statements, mode = \"write\") {\n    const response = await this.httpClient.dbBatch(statements, mode);\n    return response.data;\n  }\n};\n\n// src/storage.ts\nvar BlinkStorageImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Upload a file to project storage\n   * \n   * @param file - File, Blob, or Buffer to upload\n   * @param path - Destination path within project storage (extension will be auto-corrected to match file type)\n   * @param options - Upload options including upsert and progress callback\n   * @returns Promise resolving to upload response with public URL\n   * \n   * @example\n   * ```ts\n   * // Extension automatically corrected to match actual file type\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}`, // No extension needed!\n   *   { upsert: true }\n   * );\n   * // If file is PNG, final path will be: avatars/user123.png\n   * \n   * // Or with extension (will be corrected if wrong)\n   * const { publicUrl } = await blink.storage.upload(\n   *   pngFile,\n   *   `avatars/${user.id}.jpg`, // Wrong extension\n   *   { upsert: true }\n   * );\n   * // Final path will be: avatars/user123.png (auto-corrected!)\n   * ```\n   */\n  async upload(file, path, options = {}) {\n    try {\n      if (!file) {\n        throw new BlinkStorageError(\"File is required\");\n      }\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const maxSize = 50 * 1024 * 1024;\n      let fileSize = 0;\n      if (file instanceof File || file instanceof Blob) {\n        fileSize = file.size;\n      } else if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n        fileSize = file.length;\n      }\n      if (fileSize > maxSize) {\n        throw new BlinkStorageError(`File size (${Math.round(fileSize / 1024 / 1024)}MB) exceeds maximum allowed size (50MB)`);\n      }\n      const { correctedPath, detectedContentType } = await this.detectFileTypeAndCorrectPath(file, path);\n      const response = await this.httpClient.uploadFile(\n        `/api/storage/${this.httpClient.projectId}/upload`,\n        file,\n        correctedPath,\n        // Use corrected path with proper extension\n        {\n          upsert: options.upsert,\n          onProgress: options.onProgress,\n          contentType: detectedContentType\n          // Pass detected content type\n        }\n      );\n      if (response.data?.data?.publicUrl) {\n        return { publicUrl: response.data.data.publicUrl };\n      } else if (response.data?.publicUrl) {\n        return { publicUrl: response.data.publicUrl };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing publicUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 409) {\n          throw new BlinkStorageError(\"File already exists. Set upsert: true to overwrite.\", 409);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Upload failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Detect file type from actual file content and correct path extension\n   * This ensures the path extension always matches the actual file type\n   */\n  async detectFileTypeAndCorrectPath(file, originalPath) {\n    try {\n      const fileSignature = await this.getFileSignature(file);\n      const detectedType = this.detectFileTypeFromSignature(fileSignature);\n      let detectedContentType = detectedType.mimeType;\n      let detectedExtension = detectedType.extension;\n      if (!detectedContentType && file instanceof File && file.type) {\n        detectedContentType = file.type;\n        detectedExtension = this.getExtensionFromMimeType(file.type);\n      }\n      if (!detectedContentType) {\n        detectedContentType = \"application/octet-stream\";\n        detectedExtension = \"bin\";\n      }\n      const pathParts = originalPath.split(\"/\");\n      const fileName = pathParts[pathParts.length - 1];\n      const directory = pathParts.slice(0, -1).join(\"/\");\n      if (!fileName) {\n        throw new Error(\"Invalid path: filename cannot be empty\");\n      }\n      const nameWithoutExt = fileName.includes(\".\") ? fileName.substring(0, fileName.lastIndexOf(\".\")) : fileName;\n      const correctedFileName = `${nameWithoutExt}.${detectedExtension}`;\n      const correctedPath = directory ? `${directory}/${correctedFileName}` : correctedFileName;\n      return {\n        correctedPath,\n        detectedContentType\n      };\n    } catch (error) {\n      console.warn(\"File type detection failed, using original path:\", error);\n      return {\n        correctedPath: originalPath,\n        detectedContentType: \"application/octet-stream\"\n      };\n    }\n  }\n  /**\n   * Get the first few bytes of a file to analyze its signature\n   */\n  async getFileSignature(file) {\n    const bytesToRead = 12;\n    if (typeof Buffer !== \"undefined\" && file instanceof Buffer) {\n      return new Uint8Array(file.slice(0, bytesToRead));\n    }\n    if (file instanceof File || file instanceof Blob) {\n      const slice = file.slice(0, bytesToRead);\n      const arrayBuffer = await slice.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    }\n    throw new Error(\"Unsupported file type for signature detection\");\n  }\n  /**\n   * Detect file type from file signature (magic numbers)\n   * This is the most reliable way to detect actual file type\n   */\n  detectFileTypeFromSignature(signature) {\n    const hex = Array.from(signature).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    const signatures = {\n      // Images\n      \"ffd8ff\": { mimeType: \"image/jpeg\", extension: \"jpg\" },\n      \"89504e47\": { mimeType: \"image/png\", extension: \"png\" },\n      \"47494638\": { mimeType: \"image/gif\", extension: \"gif\" },\n      \"52494646\": { mimeType: \"image/webp\", extension: \"webp\" },\n      // RIFF (WebP container)\n      \"424d\": { mimeType: \"image/bmp\", extension: \"bmp\" },\n      \"49492a00\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      \"4d4d002a\": { mimeType: \"image/tiff\", extension: \"tiff\" },\n      // Documents\n      \"25504446\": { mimeType: \"application/pdf\", extension: \"pdf\" },\n      \"504b0304\": { mimeType: \"application/zip\", extension: \"zip\" },\n      // Also used by docx, xlsx\n      \"d0cf11e0\": { mimeType: \"application/msword\", extension: \"doc\" },\n      // Audio\n      \"494433\": { mimeType: \"audio/mpeg\", extension: \"mp3\" },\n      \"664c6143\": { mimeType: \"audio/flac\", extension: \"flac\" },\n      \"4f676753\": { mimeType: \"audio/ogg\", extension: \"ogg\" },\n      // Video\n      \"000000\": { mimeType: \"video/mp4\", extension: \"mp4\" },\n      // ftyp box\n      \"1a45dfa3\": { mimeType: \"video/webm\", extension: \"webm\" },\n      // Text\n      \"efbbbf\": { mimeType: \"text/plain\", extension: \"txt\" }\n      // UTF-8 BOM\n    };\n    for (const [sig, type] of Object.entries(signatures)) {\n      if (hex.startsWith(sig)) {\n        return type;\n      }\n    }\n    if (hex.startsWith(\"52494646\") && hex.substring(16, 24) === \"57454250\") {\n      return { mimeType: \"image/webp\", extension: \"webp\" };\n    }\n    if (hex.substring(8, 16) === \"66747970\") {\n      return { mimeType: \"video/mp4\", extension: \"mp4\" };\n    }\n    return { mimeType: \"\", extension: \"\" };\n  }\n  /**\n   * Get file extension from MIME type as fallback\n   */\n  getExtensionFromMimeType(mimeType) {\n    const mimeToExt = {\n      \"image/jpeg\": \"jpg\",\n      \"image/png\": \"png\",\n      \"image/gif\": \"gif\",\n      \"image/webp\": \"webp\",\n      \"image/bmp\": \"bmp\",\n      \"image/svg+xml\": \"svg\",\n      \"application/pdf\": \"pdf\",\n      \"text/plain\": \"txt\",\n      \"text/html\": \"html\",\n      \"text/css\": \"css\",\n      \"application/javascript\": \"js\",\n      \"application/json\": \"json\",\n      \"audio/mpeg\": \"mp3\",\n      \"audio/wav\": \"wav\",\n      \"audio/ogg\": \"ogg\",\n      \"video/mp4\": \"mp4\",\n      \"video/webm\": \"webm\",\n      \"application/zip\": \"zip\"\n    };\n    return mimeToExt[mimeType] || \"bin\";\n  }\n  /**\n   * Get a download URL for a file that triggers browser download\n   * \n   * @param path - Path to the file in project storage\n   * @param options - Download options including custom filename\n   * @returns Promise resolving to download response with download URL\n   * \n   * @example\n   * ```ts\n   * // Download with original filename\n   * const { downloadUrl, filename } = await blink.storage.download('images/photo.jpg');\n   * window.open(downloadUrl, '_blank');\n   * \n   * // Download with custom filename\n   * const { downloadUrl } = await blink.storage.download(\n   *   'images/photo.jpg',\n   *   { filename: 'my-photo.jpg' }\n   * );\n   * \n   * // Create download link in React\n   * <a href={downloadUrl} download={filename}>Download Image</a>\n   * ```\n   */\n  async download(path, options = {}) {\n    try {\n      if (!path || typeof path !== \"string\" || !path.trim()) {\n        throw new BlinkStorageError(\"Path must be a non-empty string\");\n      }\n      const response = await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/download`,\n        {\n          method: \"GET\",\n          searchParams: {\n            path: path.trim(),\n            ...options.filename && { filename: options.filename }\n          }\n        }\n      );\n      if (response.data?.downloadUrl) {\n        return {\n          downloadUrl: response.data.downloadUrl,\n          filename: response.data.filename || options.filename || path.split(\"/\").pop() || \"download\",\n          contentType: response.data.contentType,\n          size: response.data.size\n        };\n      } else {\n        throw new BlinkStorageError(\"Invalid response format: missing downloadUrl\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 404) {\n          throw new BlinkStorageError(\"File not found\", 404);\n        }\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Download failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Remove one or more files from project storage\n   * \n   * @param paths - File paths to remove\n   * @returns Promise that resolves when files are removed\n   * \n   * @example\n   * ```ts\n   * await blink.storage.remove('avatars/user1.png');\n   * await blink.storage.remove('file1.pdf', 'file2.pdf', 'file3.pdf');\n   * ```\n   */\n  async remove(...paths) {\n    try {\n      if (paths.length === 0) {\n        throw new BlinkStorageError(\"At least one path must be provided\");\n      }\n      for (const path of paths) {\n        if (!path || typeof path !== \"string\") {\n          throw new BlinkStorageError(\"All paths must be non-empty strings\");\n        }\n      }\n      await this.httpClient.request(\n        `/api/storage/${this.httpClient.projectId}/remove`,\n        {\n          method: \"DELETE\",\n          body: { paths },\n          headers: { \"Content-Type\": \"application/json\" }\n        }\n      );\n    } catch (error) {\n      if (error instanceof BlinkStorageError) {\n        throw error;\n      }\n      if (error instanceof Error && \"status\" in error) {\n        const status = error.status;\n        if (status === 400) {\n          throw new BlinkStorageError(\"Invalid request parameters\", 400);\n        }\n      }\n      throw new BlinkStorageError(\n        `Failed to remove files: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n};\n\n// src/ai.ts\nvar BlinkAIImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  // Supported image formats for validation\n  SUPPORTED_IMAGE_FORMATS = [\"jpg\", \"jpeg\", \"png\", \"gif\", \"webp\"];\n  /**\n   * Validates if a URL is a valid HTTPS image URL\n   */\n  validateImageUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      if (parsedUrl.protocol !== \"https:\") {\n        return { isValid: false, error: \"Image URLs must use HTTPS protocol\" };\n      }\n      const pathname = parsedUrl.pathname.toLowerCase();\n      const hasValidExtension = this.SUPPORTED_IMAGE_FORMATS.some(\n        (format) => pathname.endsWith(`.${format}`)\n      );\n      if (!hasValidExtension) {\n        return {\n          isValid: false,\n          error: `Image URL must end with a supported format: ${this.SUPPORTED_IMAGE_FORMATS.join(\", \")}`\n        };\n      }\n      return { isValid: true };\n    } catch (error) {\n      return { isValid: false, error: \"Invalid URL format\" };\n    }\n  }\n  /**\n   * Validates messages for image content\n   */\n  validateMessages(messages) {\n    const errors = [];\n    messages.forEach((message, messageIndex) => {\n      if (Array.isArray(message.content)) {\n        message.content.forEach((item, contentIndex) => {\n          if (item.type === \"image\") {\n            if (!item.image || typeof item.image !== \"string\") {\n              errors.push(`Message ${messageIndex}, content ${contentIndex}: Image content must have a valid image URL`);\n            } else {\n              const validation = this.validateImageUrl(item.image);\n              if (!validation.isValid) {\n                errors.push(`Message ${messageIndex}, content ${contentIndex}: ${validation.error}`);\n              }\n            }\n          }\n        });\n      }\n    });\n    return { isValid: errors.length === 0, errors };\n  }\n  /**\n   * Get MIME type for audio format\n   */\n  getMimeTypeForFormat(format) {\n    const mimeTypes = {\n      mp3: \"audio/mpeg\",\n      opus: \"audio/opus\",\n      aac: \"audio/aac\",\n      flac: \"audio/flac\",\n      wav: \"audio/wav\",\n      pcm: \"audio/pcm\"\n    };\n    return mimeTypes[format] || \"audio/mpeg\";\n  }\n  /**\n   * Generates a text response using the Blink AI engine.\n   * \n   * @param options - An object containing either:\n   *   - `prompt`: a simple string prompt\n   *   - OR `messages`: an array of chat messages for conversation\n   *   - Plus optional model, search, maxSteps, experimental_continueSteps, maxTokens, temperature, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Simple prompt\n   * const { text } = await blink.ai.generateText({ \n   *   prompt: \"Write a poem about coding\" \n   * });\n   * \n   * // Chat messages (text only)\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { role: \"system\", content: \"You are a helpful assistant\" },\n   *     { role: \"user\", content: \"Explain quantum computing\" }\n   *   ]\n   * });\n   * \n   * // With image content\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"What do you see in this image?\" },\n   *         { type: \"image\", image: \"https://example.com/photo.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // Mixed content with multiple images\n   * const { text } = await blink.ai.generateText({\n   *   messages: [\n   *     { \n   *       role: \"user\", \n   *       content: [\n   *         { type: \"text\", text: \"Compare these two images:\" },\n   *         { type: \"image\", image: \"https://example.com/image1.jpg\" },\n   *         { type: \"image\", image: \"https://example.com/image2.jpg\" }\n   *       ]\n   *     }\n   *   ]\n   * });\n   * \n   * // With options\n   * const { text, usage } = await blink.ai.generateText({\n   *   prompt: \"Summarize this article\",\n   *   model: \"gpt-4.1-mini\",\n   *   maxTokens: 150,\n   *   temperature: 0.7\n   * });\n   * \n   * // With web search (OpenAI models only)\n   * const { text, sources } = await blink.ai.generateText({\n   *   prompt: \"What are the latest developments in AI?\",\n   *   model: \"gpt-4.1-mini\",\n   *   search: true // Enables web search\n   * });\n   * \n   * // With advanced multi-step configuration\n   * const { text } = await blink.ai.generateText({\n   *   prompt: \"Research and analyze recent tech trends\",\n   *   model: \"gpt-4o\",\n   *   search: true,\n   *   maxSteps: 10, // Allow up to 10 reasoning steps\n   *   experimental_continueSteps: true // Enable continued reasoning\n   * });\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Object containing:\n   *   - `text`: Generated text string\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped (\"stop\", \"length\", etc.)\n   */\n  async generateText(options) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const requestBody = {\n        model: options.model,\n        stream: false,\n        search: options.search,\n        maxSteps: options.maxSteps,\n        experimental_continueSteps: options.experimental_continueSteps,\n        maxTokens: options.maxTokens,\n        temperature: options.temperature,\n        signal: options.signal\n      };\n      if (options.prompt) {\n        requestBody.prompt = options.prompt;\n      }\n      if (options.messages) {\n        requestBody.messages = options.messages;\n      }\n      const response = await this.httpClient.aiText(\n        options.prompt || \"\",\n        requestBody\n      );\n      if (response.data?.result) {\n        return response.data.result;\n      } else if (response.data?.text) {\n        return response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing text\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams text generation with real-time updates as the AI generates content.\n   * \n   * @param options - Same as generateText: either `prompt` or `messages` with optional parameters including search, maxSteps, experimental_continueSteps\n   * @param onChunk - Callback function that receives each text chunk as it's generated\n   * \n   * @example\n   * ```ts\n   * // Stream with prompt\n   * await blink.ai.streamText(\n   *   { prompt: \"Write a short story about space exploration\" },\n   *   (chunk) => {\n   *     process.stdout.write(chunk); // Real-time output\n   *   }\n   * );\n   * \n   * // Stream with messages\n   * await blink.ai.streamText(\n   *   { \n   *     messages: [\n   *       { role: \"system\", content: \"You are a creative writer\" },\n   *       { role: \"user\", content: \"Write a haiku about programming\" }\n   *     ]\n   *   },\n   *   (chunk) => updateUI(chunk)\n   * );\n   * ```\n   * \n   * @returns Promise<TextGenerationResponse> - Final complete response with full text and metadata\n   */\n  async streamText(options, onChunk) {\n    try {\n      if (!options.prompt && !options.messages) {\n        throw new BlinkAIError(\"Either prompt or messages is required\");\n      }\n      if (options.messages) {\n        const validation = this.validateMessages(options.messages);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Message validation failed: ${validation.errors.join(\"; \")}`);\n        }\n      }\n      const result = await this.httpClient.streamAiText(\n        options.prompt || \"\",\n        {\n          model: options.model,\n          messages: options.messages,\n          search: options.search,\n          maxSteps: options.maxSteps,\n          experimental_continueSteps: options.experimental_continueSteps,\n          maxTokens: options.maxTokens,\n          temperature: options.temperature,\n          signal: options.signal\n        },\n        onChunk\n      );\n      return {\n        text: result.text || \"\",\n        finishReason: \"stop\",\n        usage: result.usage,\n        ...result\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Text streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates structured JSON objects using AI with schema validation.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Description of what object to generate (required)\n   *   - `schema`: JSON Schema to validate the generated object\n   *   - `output`: Type of output (\"object\", \"array\", \"enum\")\n   *   - `enum`: Array of allowed values for enum output\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Generate user profile\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Generate a user profile for a software developer\",\n   *   schema: {\n   *     type: \"object\",\n   *     properties: {\n   *       name: { type: \"string\" },\n   *       age: { type: \"number\" },\n   *       skills: { type: \"array\", items: { type: \"string\" } },\n   *       experience: { type: \"number\" }\n   *     },\n   *     required: [\"name\", \"skills\"]\n   *   }\n   * });\n   * \n   * // Generate array of items\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"List 5 programming languages\",\n   *   output: \"array\",\n   *   schema: {\n   *     type: \"array\",\n   *     items: { type: \"string\" }\n   *   }\n   * });\n   * \n   * // Generate enum value\n   * const { object } = await blink.ai.generateObject({\n   *   prompt: \"Choose the best programming language for web development\",\n   *   output: \"enum\",\n   *   enum: [\"JavaScript\", \"Python\", \"TypeScript\", \"Go\"]\n   * });\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Object containing:\n   *   - `object`: The generated and validated JSON object/array/enum\n   *   - `usage`: Token usage information\n   *   - `finishReason`: Why generation stopped\n   */\n  async generateObject(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          stream: false,\n          signal: options.signal\n        }\n      );\n      if (response.data?.result) {\n        return response.data.result;\n      } else if (response.data?.object) {\n        return response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing object\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Streams structured object generation with real-time partial updates as the AI builds the object.\n   * \n   * @param options - Same as generateObject: prompt, schema, output type, etc.\n   * @param onPartial - Callback function that receives partial object updates as they're generated\n   * \n   * @example\n   * ```ts\n   * // Stream object generation with schema\n   * await blink.ai.streamObject(\n   *   {\n   *     prompt: \"Generate a detailed product catalog entry\",\n   *     schema: {\n   *       type: \"object\",\n   *       properties: {\n   *         name: { type: \"string\" },\n   *         price: { type: \"number\" },\n   *         description: { type: \"string\" },\n   *         features: { type: \"array\", items: { type: \"string\" } }\n   *       }\n   *     }\n   *   },\n   *   (partial) => {\n   *     console.log(\"Partial update:\", partial);\n   *     updateProductForm(partial); // Update UI in real-time\n   *   }\n   * );\n   * ```\n   * \n   * @returns Promise<ObjectGenerationResponse> - Final complete object with metadata\n   */\n  async streamObject(options, onPartial) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const result = await this.httpClient.streamAiObject(\n        options.prompt,\n        {\n          model: options.model,\n          output: options.output,\n          schema: options.schema,\n          enum: options.enum,\n          signal: options.signal\n        },\n        onPartial\n      );\n      return {\n        object: result.object || {},\n        finishReason: \"stop\",\n        usage: result.usage,\n        ...result\n      };\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Object streaming failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Generates images from text descriptions using Gemini 2.5 Flash Image.\n   * \n   * @param options - Object containing:\n   *   - `prompt`: Text description of the desired image (required, up to 100k characters)\n   *   - `n`: Number of images to generate (default: 1)\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Basic image generation\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A serene landscape with mountains and a lake at sunset\"\n   * });\n   * console.log(\"Image URL:\", data[0].url);\n   * \n   * // Multiple images\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A futuristic city skyline with flying cars\",\n   *   n: 3\n   * });\n   * data.forEach((img, i) => console.log(`Image ${i+1}:`, img.url));\n   * \n   * // Detailed prompt for better results\n   * const { data } = await blink.ai.generateImage({\n   *   prompt: \"A cute robot mascot for a tech company, digital art style, vibrant colors, modern design, friendly expression\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of generated images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: Always \"gemini-2.5-flash-image-preview\"\n   */\n  async generateImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        {\n          n: options.n,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Modifies existing images using Gemini 2.5 Flash Image with text prompts for image-to-image editing.\n   * \n   * @param options - Object containing:\n   *   - `images`: Array of public image URLs to modify (required, up to 50 images)\n   *   - `prompt`: Text description of desired modifications (required, up to 100k characters)\n   *   - `n`: Number of output images to generate (default: 1)\n   *   - Plus optional signal parameter\n   * \n   * @example\n   * ```ts\n   * // Professional headshots from casual photos\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\n   *     \"https://storage.example.com/user-photo-1.jpg\",\n   *     \"https://storage.example.com/user-photo-2.jpg\"\n   *   ],\n   *   prompt: \"Transform into professional business headshots with studio lighting\",\n   *   n: 4\n   * });\n   * data.forEach((img, i) => console.log(`Headshot ${i+1}:`, img.url));\n   * \n   * // Artistic style transformation\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/portrait.jpg\"],\n   *   prompt: \"Transform into oil painting style with dramatic lighting\"\n   * });\n   * \n   * // Background replacement\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [\"https://storage.example.com/product.jpg\"],\n   *   prompt: \"Remove background and place on clean white studio background\",\n   *   n: 2\n   * });\n   * \n   * // Batch processing multiple photos\n   * const userPhotos = [\n   *   \"https://storage.example.com/photo1.jpg\",\n   *   \"https://storage.example.com/photo2.jpg\",\n   *   \"https://storage.example.com/photo3.jpg\"\n   * ];\n   * const { data } = await blink.ai.modifyImage({\n   *   images: userPhotos,\n   *   prompt: \"Convert to black and white vintage style photographs\"\n   * });\n   * \n   * //  Style Transfer - IMPORTANT: Provide all images in array\n   * //  WRONG - Don't reference other images in prompt\n   * const wrong = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl],\n   *   prompt: `Apply hairstyle from ${referenceUrl}`\n   * });\n   * \n   * //  CORRECT - Provide all images in array\n   * const { data } = await blink.ai.modifyImage({\n   *   images: [userPhotoUrl, hairstyleReferenceUrl],\n   *   prompt: \"Apply the hairstyle from the second image to the person in the first image\"\n   * });\n   * ```\n   * \n   * @returns Promise<ImageGenerationResponse> - Object containing:\n   *   - `data`: Array of modified images with URLs\n   *   - `created`: Timestamp of generation\n   *   - `model`: Always \"gemini-2.5-flash-image-preview\"\n   */\n  async modifyImage(options) {\n    try {\n      if (!options.prompt) {\n        throw new BlinkAIError(\"Prompt is required\");\n      }\n      if (!options.images || !Array.isArray(options.images) || options.images.length === 0) {\n        throw new BlinkAIError(\"Images array is required and must contain at least one image URL\");\n      }\n      if (options.images.length > 50) {\n        throw new BlinkAIError(\"Maximum 50 images allowed\");\n      }\n      for (let i = 0; i < options.images.length; i++) {\n        const validation = this.validateImageUrl(options.images[i]);\n        if (!validation.isValid) {\n          throw new BlinkAIError(`Image ${i + 1}: ${validation.error}`);\n        }\n      }\n      const response = await this.httpClient.aiImage(\n        options.prompt,\n        // Non-null assertion since we validated above\n        {\n          images: options.images,\n          n: options.n,\n          signal: options.signal\n        }\n      );\n      let imageResponse;\n      if (response.data?.result?.data) {\n        imageResponse = response.data.result;\n      } else if (response.data?.data) {\n        imageResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing image data\");\n      }\n      if (!Array.isArray(imageResponse.data)) {\n        throw new BlinkAIError(\"Invalid response format: data should be an array\");\n      }\n      imageResponse.data = imageResponse.data.map((item) => {\n        if (typeof item === \"string\") {\n          return { url: item };\n        } else if (item.url) {\n          return item;\n        } else {\n          throw new BlinkAIError(\"Invalid image response format\");\n        }\n      });\n      return imageResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Image modification failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Converts text to speech using AI voice synthesis models.\n   * \n   * @param options - Object containing:\n   *   - `text`: Text content to convert to speech (required)\n   *   - `voice`: Voice to use (\"alloy\", \"echo\", \"fable\", \"onyx\", \"nova\", \"shimmer\")\n   *   - `response_format`: Audio format (\"mp3\", \"opus\", \"aac\", \"flac\", \"wav\", \"pcm\")\n   *   - `speed`: Speech speed (0.25 to 4.0, default: 1.0)\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Basic text-to-speech\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Hello, welcome to our AI-powered application!\"\n   * });\n   * console.log(\"Audio URL:\", url);\n   * \n   * // Custom voice and format\n   * const { url, voice, format } = await blink.ai.generateSpeech({\n   *   text: \"This is a demonstration of our speech synthesis capabilities.\",\n   *   voice: \"nova\",\n   *   response_format: \"wav\",\n   *   speed: 1.2\n   * });\n   * console.log(`Generated ${format} audio with ${voice} voice:`, url);\n   * \n   * // Slow, clear speech for accessibility\n   * const { url } = await blink.ai.generateSpeech({\n   *   text: \"Please listen carefully to these important instructions.\",\n   *   voice: \"echo\",\n   *   speed: 0.8\n   * });\n   * ```\n   * \n   * @returns Promise<SpeechGenerationResponse> - Object containing:\n   *   - `url`: URL to the generated audio file\n   *   - `voice`: Voice used for generation\n   *   - `format`: Audio format\n   *   - `mimeType`: MIME type of the audio\n   */\n  async generateSpeech(options) {\n    try {\n      if (!options.text) {\n        throw new BlinkAIError(\"Text is required\");\n      }\n      const response = await this.httpClient.aiSpeech(\n        options.text,\n        {\n          model: options.model,\n          voice: options.voice,\n          response_format: options.response_format,\n          speed: options.speed,\n          signal: options.signal\n        }\n      );\n      let speechResponse;\n      if (response.data?.result) {\n        speechResponse = response.data.result;\n      } else if (response.data?.url) {\n        speechResponse = response.data;\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing speech data\");\n      }\n      if (!speechResponse.url) {\n        if (typeof response.data === \"string\") {\n          speechResponse = {\n            url: response.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else if (response.data?.data) {\n          speechResponse = {\n            url: response.data.data,\n            voice: options.voice || \"alloy\",\n            format: options.response_format || \"mp3\",\n            mimeType: this.getMimeTypeForFormat(options.response_format || \"mp3\")\n          };\n        } else {\n          throw new BlinkAIError(\"Invalid response format: no audio URL found\");\n        }\n      }\n      if (!speechResponse.voice) {\n        speechResponse.voice = options.voice || \"alloy\";\n      }\n      if (!speechResponse.format) {\n        speechResponse.format = options.response_format || \"mp3\";\n      }\n      if (!speechResponse.mimeType) {\n        speechResponse.mimeType = this.getMimeTypeForFormat(speechResponse.format);\n      }\n      return speechResponse;\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Speech generation failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n  /**\n   * Transcribes audio content to text using AI speech recognition models.\n   * \n   * @param options - Object containing:\n   *   - `audio`: Audio input as URL string, base64 string, or number array buffer (required)\n   *   - `language`: Language code for transcription (e.g., \"en\", \"es\", \"fr\")\n   *   - `response_format`: Output format (\"json\", \"text\", \"srt\", \"verbose_json\", \"vtt\")\n   *   - Plus optional model, signal parameters\n   * \n   * @example\n   * ```ts\n   * // Transcribe from URL\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/meeting-recording.mp3\"\n   * });\n   * console.log(\"Transcription:\", text);\n   * \n   * // Transcribe with language hint\n   * const { text, language } = await blink.ai.transcribeAudio({\n   *   audio: \"https://example.com/spanish-audio.wav\",\n   *   language: \"es\"\n   * });\n   * console.log(`Transcribed ${language}:`, text);\n   * \n   * // Transcribe with timestamps (verbose format)\n   * const result = await blink.ai.transcribeAudio({\n   *   audio: audioFileUrl,\n   *   response_format: \"verbose_json\"\n   * });\n   * result.segments?.forEach(segment => {\n   *   console.log(`${segment.start}s - ${segment.end}s: ${segment.text}`);\n   * });\n   * \n   * // Transcribe from audio buffer\n   * const audioBuffer = new Array(1024).fill(0); // Your audio data\n   * const { text } = await blink.ai.transcribeAudio({\n   *   audio: audioBuffer,\n   *   language: \"en\"\n   * });\n   * ```\n   * \n   * @returns Promise<TranscriptionResponse> - Object containing:\n   *   - `text`: Transcribed text content\n   *   - `transcript`: Alias for text\n   *   - `segments`: Array of timestamped segments (if verbose format)\n   *   - `language`: Detected language\n   *   - `duration`: Audio duration in seconds\n   */\n  async transcribeAudio(options) {\n    try {\n      if (!options.audio) {\n        throw new BlinkAIError(\"Audio is required\");\n      }\n      const response = await this.httpClient.aiTranscribe(\n        options.audio,\n        {\n          model: options.model,\n          language: options.language,\n          response_format: options.response_format,\n          signal: options.signal\n        }\n      );\n      if (response.data?.result) {\n        return response.data.result;\n      } else if (response.data?.text || response.data?.transcript) {\n        return {\n          text: response.data.text || response.data.transcript,\n          transcript: response.data.transcript || response.data.text,\n          ...response.data\n        };\n      } else {\n        throw new BlinkAIError(\"Invalid response format: missing transcription text\");\n      }\n    } catch (error) {\n      if (error instanceof BlinkAIError) {\n        throw error;\n      }\n      throw new BlinkAIError(\n        `Audio transcription failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        void 0,\n        { originalError: error }\n      );\n    }\n  }\n};\n\n// src/data.ts\nvar BlinkDataImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  async extractFromUrl(url, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const request = { url, chunking, chunkSize };\n    const response = await this.httpClient.dataExtractFromUrl(this.projectId, request);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async extractFromBlob(file, options = {}) {\n    const { chunking = false, chunkSize } = options;\n    const response = await this.httpClient.dataExtractFromBlob(this.projectId, file, chunking, chunkSize);\n    return chunking ? response.data.chunks : response.data.text;\n  }\n  async scrape(url) {\n    const request = {\n      url,\n      formats: [\"markdown\", \"html\", \"links\", \"extract\", \"metadata\"]\n    };\n    const response = await this.httpClient.dataScrape(this.projectId, request);\n    const data = response.data;\n    return {\n      markdown: data.markdown || \"\",\n      html: data.html || \"\",\n      metadata: {\n        title: data.metadata?.title || \"\",\n        description: data.metadata?.description || \"\",\n        url: data.metadata?.url || url,\n        domain: data.metadata?.domain || new URL(url).hostname,\n        favicon: data.metadata?.favicon,\n        image: data.metadata?.image,\n        author: data.metadata?.author,\n        publishedTime: data.metadata?.publishedTime,\n        modifiedTime: data.metadata?.modifiedTime,\n        type: data.metadata?.type,\n        siteName: data.metadata?.siteName,\n        locale: data.metadata?.locale,\n        keywords: data.metadata?.keywords || []\n      },\n      links: data.links || [],\n      extract: {\n        title: data.extract?.title || data.metadata?.title || \"\",\n        description: data.extract?.description || data.metadata?.description || \"\",\n        headings: data.extract?.headings || [],\n        text: data.extract?.text || data.markdown || \"\"\n      }\n    };\n  }\n  async screenshot(url, options = {}) {\n    const request = { url, ...options };\n    const response = await this.httpClient.dataScreenshot(this.projectId, request);\n    return response.data.url;\n  }\n  async fetch(request) {\n    const response = await this.httpClient.dataFetch(this.projectId, request);\n    if (\"status\" in response.data && \"headers\" in response.data) {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from fetch endpoint\");\n  }\n  async fetchAsync(request) {\n    const asyncRequest = { ...request, async: true };\n    const response = await this.httpClient.dataFetch(this.projectId, asyncRequest);\n    if (\"status\" in response.data && response.data.status === \"triggered\") {\n      return response.data;\n    }\n    throw new BlinkDataError(\"Unexpected response format from async fetch endpoint\");\n  }\n  async search(query, options) {\n    const normalizeType = (type) => {\n      switch (type) {\n        case \"news\":\n          return \"nws\";\n        case \"images\":\n        case \"image\":\n          return \"isch\";\n        case \"videos\":\n        case \"video\":\n          return \"vid\";\n        case \"shopping\":\n        case \"shop\":\n          return \"shop\";\n        default:\n          return void 0;\n      }\n    };\n    const request = {\n      q: query,\n      location: options?.location,\n      hl: options?.language || \"en\",\n      tbm: normalizeType(options?.type),\n      num: options?.limit\n    };\n    const response = await this.httpClient.dataSearch(this.projectId, request);\n    return response.data;\n  }\n};\n\n// src/realtime.ts\nvar getWebSocketClass = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  }\n  try {\n    const WS = __require(\"ws\");\n    return WS;\n  } catch (error) {\n    throw new BlinkRealtimeError('WebSocket is not available. Install \"ws\" package for Node.js environments.');\n  }\n};\nvar BlinkRealtimeChannel = class {\n  constructor(channelName, httpClient, projectId) {\n    this.channelName = channelName;\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  messageCallbacks = [];\n  presenceCallbacks = [];\n  websocket = null;\n  isSubscribed = false;\n  isConnected = false;\n  isConnecting = false;\n  reconnectTimer = null;\n  heartbeatTimer = null;\n  reconnectAttempts = 0;\n  // Message queuing for when socket is not ready\n  messageQueue = [];\n  pendingSubscription = null;\n  // Connection promise for awaiting readiness\n  connectionPromise = null;\n  /**\n   * Check if channel is ready for publishing\n   */\n  isReady() {\n    return this.isConnected && this.isSubscribed;\n  }\n  async subscribe(options = {}) {\n    if (this.isSubscribed) {\n      return;\n    }\n    await this.ensureConnected();\n    return new Promise((resolve, reject) => {\n      if (this.pendingSubscription) {\n        clearTimeout(this.pendingSubscription.timeout);\n        this.pendingSubscription.reject(new BlinkRealtimeError(\"Subscription cancelled by new subscription request\"));\n      }\n      const timeout = setTimeout(() => {\n        this.pendingSubscription = null;\n        reject(new BlinkRealtimeError(\"Subscription timeout - no acknowledgment from server\"));\n      }, 1e4);\n      this.pendingSubscription = {\n        options,\n        resolve: () => {\n          clearTimeout(timeout);\n          this.pendingSubscription = null;\n          this.isSubscribed = true;\n          this.startHeartbeat();\n          resolve();\n        },\n        reject: (error) => {\n          clearTimeout(timeout);\n          this.pendingSubscription = null;\n          reject(error);\n        },\n        timeout\n      };\n      const subscribeMessage = {\n        type: \"subscribe\",\n        payload: {\n          channel: this.channelName,\n          userId: options.userId,\n          metadata: options.metadata\n        }\n      };\n      this.sendMessage(JSON.stringify(subscribeMessage)).catch((error) => {\n        if (this.pendingSubscription) {\n          this.pendingSubscription.reject(error);\n        }\n      });\n    });\n  }\n  async unsubscribe() {\n    if (!this.isSubscribed) {\n      return;\n    }\n    if (this.pendingSubscription) {\n      clearTimeout(this.pendingSubscription.timeout);\n      this.pendingSubscription.reject(new BlinkRealtimeError(\"Subscription cancelled by unsubscribe\"));\n      this.pendingSubscription = null;\n    }\n    if (this.websocket && this.websocket.readyState === 1) {\n      const unsubscribeMessage = {\n        type: \"unsubscribe\",\n        payload: {\n          channel: this.channelName\n        }\n      };\n      this.websocket.send(JSON.stringify(unsubscribeMessage));\n    }\n    this.cleanup();\n  }\n  async publish(type, data, options = {}) {\n    await this.ensureConnected();\n    const publishMessage = {\n      type: \"publish\",\n      payload: {\n        channel: this.channelName,\n        type,\n        data,\n        userId: options.userId,\n        metadata: options.metadata\n      }\n    };\n    return this.sendMessage(JSON.stringify(publishMessage));\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n    return () => {\n      const index = this.messageCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.messageCallbacks.splice(index, 1);\n      }\n    };\n  }\n  onPresence(callback) {\n    this.presenceCallbacks.push(callback);\n    return () => {\n      const index = this.presenceCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.presenceCallbacks.splice(index, 1);\n      }\n    };\n  }\n  async getPresence() {\n    try {\n      const response = await this.httpClient.realtimeGetPresence(this.projectId, this.channelName);\n      return response.data.users || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get presence for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  async getMessages(options = {}) {\n    try {\n      const response = await this.httpClient.realtimeGetMessages(this.projectId, {\n        channel: this.channelName,\n        limit: options.limit,\n        start: options.after || \"-\",\n        // after = start from this ID onwards, default to oldest\n        end: options.before || \"+\"\n        // before = end at this ID, default to newest\n      });\n      return response.data.messages || [];\n    } catch (error) {\n      throw new BlinkRealtimeError(\n        `Failed to get messages for channel ${this.channelName}: ${error instanceof Error ? error.message : \"Unknown error\"}`\n      );\n    }\n  }\n  /**\n   * Ensure WebSocket connection is established and ready\n   */\n  async ensureConnected() {\n    if (this.isConnected && this.websocket?.readyState === 1) {\n      return;\n    }\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n    this.connectionPromise = this.connectWebSocket();\n    try {\n      await this.connectionPromise;\n    } finally {\n      this.connectionPromise = null;\n    }\n  }\n  /**\n   * Send a message, queuing if socket not ready\n   */\n  sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      let messageObj;\n      try {\n        messageObj = JSON.parse(message);\n      } catch (error) {\n        reject(new BlinkRealtimeError(\"Invalid message format\"));\n        return;\n      }\n      const timeout = setTimeout(() => {\n        const index = this.messageQueue.findIndex((q) => q.resolve === resolve);\n        if (index > -1) {\n          this.messageQueue.splice(index, 1);\n        }\n        reject(new BlinkRealtimeError(\"Message send timeout - no response from server\"));\n      }, 1e4);\n      const queuedMessage = {\n        message,\n        resolve,\n        reject,\n        timeout\n      };\n      if (this.websocket && this.websocket.readyState === 1) {\n        if (messageObj.type === \"publish\") {\n          this.sendQueuedMessage(queuedMessage);\n        } else {\n          this.websocket.send(message);\n          clearTimeout(timeout);\n          resolve(\"sent\");\n        }\n      } else {\n        this.messageQueue.push(queuedMessage);\n      }\n    });\n  }\n  /**\n   * Send a queued message and set up response handling\n   */\n  sendQueuedMessage(queuedMessage) {\n    const { message, resolve, reject, timeout } = queuedMessage;\n    const handleResponse = (event) => {\n      try {\n        const response = JSON.parse(event.data);\n        if (response.type === \"published\" && response.payload.channel === this.channelName) {\n          clearTimeout(timeout);\n          this.websocket.removeEventListener(\"message\", handleResponse);\n          resolve(response.payload.messageId);\n        } else if (response.type === \"error\") {\n          clearTimeout(timeout);\n          this.websocket.removeEventListener(\"message\", handleResponse);\n          reject(new BlinkRealtimeError(`Server error: ${response.payload.error}`));\n        }\n      } catch (err) {\n      }\n    };\n    const originalTimeout = timeout;\n    const cleanupTimeout = setTimeout(() => {\n      if (this.websocket) {\n        this.websocket.removeEventListener(\"message\", handleResponse);\n      }\n      reject(new BlinkRealtimeError(\"Message send timeout - no response from server\"));\n    }, 1e4);\n    queuedMessage.timeout = cleanupTimeout;\n    clearTimeout(originalTimeout);\n    this.websocket.addEventListener(\"message\", handleResponse);\n    this.websocket.send(message);\n  }\n  /**\n   * Flush all queued messages when connection becomes ready\n   */\n  flushMessageQueue() {\n    if (!this.websocket || this.websocket.readyState !== 1) {\n      return;\n    }\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((queuedMessage) => {\n      try {\n        const messageObj = JSON.parse(queuedMessage.message);\n        if (messageObj.type === \"publish\") {\n          this.sendQueuedMessage(queuedMessage);\n        } else {\n          this.websocket.send(queuedMessage.message);\n          clearTimeout(queuedMessage.timeout);\n          queuedMessage.resolve(\"sent\");\n        }\n      } catch (error) {\n        clearTimeout(queuedMessage.timeout);\n        queuedMessage.reject(new BlinkRealtimeError(\"Invalid queued message format\"));\n      }\n    });\n  }\n  async connectWebSocket() {\n    if (this.websocket && this.websocket.readyState === 1) {\n      this.isConnected = true;\n      return;\n    }\n    if (this.isConnecting) {\n      return new Promise((resolve, reject) => {\n        const checkConnection = () => {\n          if (this.isConnected) {\n            resolve();\n          } else if (!this.isConnecting) {\n            reject(new BlinkRealtimeError(\"Connection failed\"));\n          } else {\n            setTimeout(checkConnection, 100);\n          }\n        };\n        checkConnection();\n      });\n    }\n    this.isConnecting = true;\n    this.isConnected = false;\n    return new Promise((resolve, reject) => {\n      try {\n        const httpClient = this.httpClient;\n        const coreUrl = httpClient.coreUrl || \"https://core.blink.new\";\n        const baseUrl = coreUrl.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\");\n        const wsUrl = `${baseUrl}?project_id=${this.projectId}`;\n        console.log(`\\u{1F517} Attempting WebSocket connection to: ${wsUrl}`);\n        const WSClass = getWebSocketClass();\n        this.websocket = new WSClass(wsUrl);\n        if (!this.websocket) {\n          this.isConnecting = false;\n          reject(new BlinkRealtimeError(\"Failed to create WebSocket instance\"));\n          return;\n        }\n        this.websocket.onopen = () => {\n          console.log(`\\u{1F517} Connected to realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          this.flushMessageQueue();\n          resolve();\n        };\n        this.websocket.onmessage = (event) => {\n          try {\n            const message = JSON.parse(event.data);\n            this.handleWebSocketMessage(message);\n          } catch (error) {\n            console.error(\"Failed to parse WebSocket message:\", error);\n          }\n        };\n        this.websocket.onclose = () => {\n          console.log(`\\u{1F50C} Disconnected from realtime for project ${this.projectId}`);\n          this.isConnecting = false;\n          this.isConnected = false;\n          this.isSubscribed = false;\n          this.rejectQueuedMessages(new BlinkRealtimeError(\"WebSocket connection closed\"));\n          if (this.pendingSubscription) {\n            clearTimeout(this.pendingSubscription.timeout);\n            this.pendingSubscription.reject(new BlinkRealtimeError(\"Connection closed during subscription\"));\n            this.pendingSubscription = null;\n          }\n          this.scheduleReconnect();\n        };\n        this.websocket.onerror = (error) => {\n          console.error(\"WebSocket error:\", error);\n          console.error(\"WebSocket URL was:\", wsUrl);\n          console.error(\"WebSocket readyState:\", this.websocket?.readyState);\n          this.isConnecting = false;\n          this.isConnected = false;\n          reject(new BlinkRealtimeError(`WebSocket connection failed to ${wsUrl}`));\n        };\n        setTimeout(() => {\n          if (this.websocket?.readyState !== 1) {\n            this.isConnecting = false;\n            reject(new BlinkRealtimeError(\"WebSocket connection timeout\"));\n          }\n        }, 1e4);\n      } catch (error) {\n        this.isConnecting = false;\n        reject(new BlinkRealtimeError(`Failed to create WebSocket connection: ${error instanceof Error ? error.message : \"Unknown error\"}`));\n      }\n    });\n  }\n  /**\n   * Reject all queued messages with the given error\n   */\n  rejectQueuedMessages(error) {\n    const queue = [...this.messageQueue];\n    this.messageQueue = [];\n    queue.forEach((queuedMessage) => {\n      clearTimeout(queuedMessage.timeout);\n      queuedMessage.reject(error);\n    });\n  }\n  handleWebSocketMessage(message) {\n    switch (message.type) {\n      case \"message\":\n        this.messageCallbacks.forEach((callback) => {\n          try {\n            callback(message.payload);\n          } catch (error) {\n            console.error(\"Error in message callback:\", error);\n          }\n        });\n        break;\n      case \"presence\":\n        this.presenceCallbacks.forEach((callback) => {\n          try {\n            const users = message.payload.data?.users || [];\n            callback(users);\n          } catch (error) {\n            console.error(\"Error in presence callback:\", error);\n          }\n        });\n        break;\n      case \"subscribed\":\n        console.log(`\\u2705 Subscribed to channel: ${message.payload.channel}`);\n        if (this.pendingSubscription && message.payload.channel === this.channelName) {\n          this.pendingSubscription.resolve();\n        }\n        break;\n      case \"unsubscribed\":\n        console.log(`\\u274C Unsubscribed from channel: ${message.payload.channel}`);\n        break;\n      case \"published\":\n        break;\n      case \"pong\":\n        break;\n      case \"error\":\n        console.error(\"Realtime error:\", message.payload.error);\n        if (this.pendingSubscription && message.payload.channel === this.channelName) {\n          this.pendingSubscription.reject(new BlinkRealtimeError(`Subscription error: ${message.payload.error}`));\n        }\n        break;\n      default:\n        console.log(\"Unknown message type:\", message.type);\n    }\n  }\n  startHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n    }\n    this.heartbeatTimer = globalThis.setInterval(() => {\n      if (this.websocket && this.websocket.readyState === 1) {\n        this.websocket.send(JSON.stringify({ type: \"ping\", payload: {} }));\n      }\n    }, 25e3);\n  }\n  scheduleReconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    if (!this.isSubscribed && !this.pendingSubscription) {\n      return;\n    }\n    this.reconnectAttempts++;\n    const baseDelay = Math.min(3e4, Math.pow(2, this.reconnectAttempts) * 1e3);\n    const jitter = Math.random() * 1e3;\n    const delay = baseDelay + jitter;\n    console.log(`\\u{1F504} Scheduling reconnect attempt ${this.reconnectAttempts} in ${Math.round(delay)}ms`);\n    this.reconnectTimer = globalThis.setTimeout(async () => {\n      if (this.isSubscribed || this.pendingSubscription) {\n        try {\n          await this.connectWebSocket();\n          if (this.isSubscribed && this.websocket) {\n            const subscribeMessage = {\n              type: \"subscribe\",\n              payload: {\n                channel: this.channelName\n              }\n            };\n            this.websocket.send(JSON.stringify(subscribeMessage));\n            this.startHeartbeat();\n          }\n        } catch (error) {\n          console.error(\"Reconnection failed:\", error);\n          this.scheduleReconnect();\n        }\n      }\n    }, delay);\n  }\n  cleanup() {\n    this.isSubscribed = false;\n    this.isConnected = false;\n    this.isConnecting = false;\n    if (this.pendingSubscription) {\n      clearTimeout(this.pendingSubscription.timeout);\n      this.pendingSubscription.reject(new BlinkRealtimeError(\"Channel cleanup\"));\n      this.pendingSubscription = null;\n    }\n    this.rejectQueuedMessages(new BlinkRealtimeError(\"Channel cleanup\"));\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    if (this.websocket) {\n      this.websocket.close();\n      this.websocket = null;\n    }\n    this.messageCallbacks = [];\n    this.presenceCallbacks = [];\n  }\n};\nvar BlinkRealtimeImpl = class {\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n  }\n  channels = /* @__PURE__ */ new Map();\n  handlers = {};\n  channel(name) {\n    if (!this.channels.has(name)) {\n      this.channels.set(name, new BlinkRealtimeChannel(name, this.httpClient, this.projectId));\n    }\n    return this.channels.get(name);\n  }\n  async subscribe(channelName, callback, options = {}) {\n    const channel = this.channel(channelName);\n    await channel.subscribe(options);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: true\n    };\n    state.msgHandlers.add(callback);\n    const messageUnsub = channel.onMessage(callback);\n    return () => {\n      messageUnsub();\n      state.msgHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n  async publish(channelName, type, data, options = {}) {\n    const channel = this.channel(channelName);\n    return channel.publish(type, data, options);\n  }\n  async presence(channelName) {\n    const channel = this.channel(channelName);\n    return channel.getPresence();\n  }\n  onPresence(channelName, callback) {\n    const channel = this.channel(channelName);\n    const state = this.handlers[channelName] ??= {\n      msgHandlers: /* @__PURE__ */ new Set(),\n      presHandlers: /* @__PURE__ */ new Set(),\n      subscribed: false\n    };\n    state.presHandlers.add(callback);\n    const presenceUnsub = channel.onPresence(callback);\n    return () => {\n      presenceUnsub();\n      state.presHandlers.delete(callback);\n      if (state.msgHandlers.size === 0 && state.presHandlers.size === 0) {\n        channel.unsubscribe();\n        delete this.handlers[channelName];\n      }\n    };\n  }\n};\n\n// src/notifications.ts\nvar BlinkNotificationsImpl = class {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n  /**\n   * Sends an email using the Blink Notifications API.\n   *\n   * @param params - An object containing the details for the email.\n   *   - `to`: The recipient's email address or an array of addresses.\n   *   - `subject`: The subject line of the email.\n   *   - `html`: The HTML body of the email. For best results across all email\n   *             clients (like Gmail, Outlook), use inline CSS and table-based layouts.\n   *   - `text`: A plain-text version of the email body (optional).\n   *   - `from`: A custom sender name (e.g., \"Acme Inc\"). The email address will\n   *             be auto-generated by the project (e.g., \"noreply@project.blink-email.com\").\n   *   - `replyTo`: An email address for recipients to reply to (optional).\n   *   - `cc`: A CC recipient's email address or an array of addresses (optional).\n   *   - `bcc`: A BCC recipient's email address or an array of addresses (optional).\n   *   - `attachments`: An array of objects for files to attach, each with a `url`.\n   *                    The file at the URL will be fetched and attached by the server.\n   *\n   * @example\n   * ```ts\n   * // Send a simple email\n   * const { success, messageId } = await blink.notifications.email({\n   *   to: 'customer@example.com',\n   *   subject: 'Your order has shipped!',\n   *   html: '<h1>Order Confirmation</h1><p>Your order #12345 is on its way.</p>'\n   * });\n   *\n   * // Send an email with attachments and a custom from name\n   * const { success } = await blink.notifications.email({\n   *   to: ['team@example.com', 'manager@example.com'],\n   *   subject: 'New Invoice',\n   *   from: 'Blink Invoicing',\n   *   html: '<p>Please find the invoice attached.</p>',\n   *   attachments: [\n   *     { url: 'https://example.com/invoice.pdf', filename: 'invoice.pdf' }\n   *   ]\n   * });\n   * ```\n   *\n   * @returns A promise that resolves with an object containing the status of the email send.\n   *   - `success`: A boolean indicating if the email was sent successfully.\n   *   - `messageId`: The unique ID of the message from the email provider.\n   */\n  async email(params) {\n    try {\n      if (!params.to || !params.subject || !params.html && !params.text) {\n        throw new BlinkNotificationsError('The \"to\", \"subject\", and either \"html\" or \"text\" fields are required.');\n      }\n      const response = await this.httpClient.post(`/api/notifications/${this.httpClient.projectId}/email`, params);\n      if (!response.data || typeof response.data.success !== \"boolean\") {\n        throw new BlinkNotificationsError(\"Invalid response from email API\");\n      }\n      return response.data;\n    } catch (error) {\n      if (error instanceof BlinkNotificationsError) {\n        throw error;\n      }\n      const errorMessage = error.response?.data?.error?.message || error.message || \"An unknown error occurred\";\n      throw new BlinkNotificationsError(`Failed to send email: ${errorMessage}`, error.response?.status, error.response?.data?.error);\n    }\n  }\n};\n\n// src/analytics.ts\nvar SESSION_DURATION = 30 * 60 * 1e3;\nvar MAX_BATCH_SIZE = 10;\nvar BATCH_TIMEOUT = 3e3;\nvar MAX_STRING_LENGTH = 256;\nvar BlinkAnalyticsImpl = class {\n  httpClient;\n  projectId;\n  queue = [];\n  timer = null;\n  enabled = true;\n  userId = null;\n  userEmail = null;\n  hasTrackedPageview = false;\n  utmParams = {};\n  persistedAttribution = {};\n  constructor(httpClient, projectId) {\n    this.httpClient = httpClient;\n    this.projectId = projectId;\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    if (navigator.doNotTrack === \"1\") {\n      this.enabled = false;\n      return;\n    }\n    this.loadPersistedAttribution();\n    this.captureUTMParams();\n    this.loadQueue();\n    this.trackPageview();\n    this.setupRouteChangeListener();\n    this.setupUnloadListener();\n  }\n  /**\n   * Generate project-scoped storage key for analytics\n   */\n  getStorageKey(suffix) {\n    return `blinkAnalytics${suffix}_${this.projectId}`;\n  }\n  /**\n   * Log a custom analytics event\n   */\n  log(eventName, data = {}) {\n    if (!this.enabled || typeof window === \"undefined\") {\n      return;\n    }\n    const event = this.buildEvent(eventName, data);\n    this.enqueue(event);\n  }\n  /**\n   * Disable analytics tracking\n   */\n  disable() {\n    this.enabled = false;\n    this.clearTimer();\n  }\n  /**\n   * Cleanup analytics instance (remove from global tracking)\n   */\n  destroy() {\n    this.disable();\n    if (typeof window !== \"undefined\") {\n      window.__blinkAnalyticsInstances?.delete(this);\n    }\n  }\n  /**\n   * Enable analytics tracking\n   */\n  enable() {\n    this.enabled = true;\n  }\n  /**\n   * Check if analytics is enabled\n   */\n  isEnabled() {\n    return this.enabled;\n  }\n  /**\n   * Set the user ID for analytics events\n   */\n  setUserId(userId) {\n    this.userId = userId;\n  }\n  /**\n   * Set the user email for analytics events\n   */\n  setUserEmail(email) {\n    this.userEmail = email;\n  }\n  /**\n   * Clear persisted attribution data\n   */\n  clearAttribution() {\n    this.persistedAttribution = {};\n    try {\n      localStorage.removeItem(this.getStorageKey(\"Attribution\"));\n    } catch {\n    }\n  }\n  // Private methods\n  buildEvent(type, data = {}) {\n    const sessionId = this.getOrCreateSessionId();\n    const channel = this.detectChannel();\n    return {\n      type,\n      timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n      project_id: this.projectId,\n      user_id: this.userId,\n      user_email: this.userEmail,\n      session_id: sessionId,\n      pathname: window.location.pathname,\n      referrer: document.referrer || null,\n      screen_width: window.innerWidth,\n      channel,\n      utm_source: this.utmParams.utm_source || this.persistedAttribution.utm_source || null,\n      utm_medium: this.utmParams.utm_medium || this.persistedAttribution.utm_medium || null,\n      utm_campaign: this.utmParams.utm_campaign || this.persistedAttribution.utm_campaign || null,\n      utm_content: this.utmParams.utm_content || this.persistedAttribution.utm_content || null,\n      utm_term: this.utmParams.utm_term || this.persistedAttribution.utm_term || null,\n      ...this.sanitizeData(data)\n    };\n  }\n  sanitizeData(data) {\n    if (typeof data === \"string\") {\n      return data.length > MAX_STRING_LENGTH ? data.slice(0, MAX_STRING_LENGTH - 3) + \"...\" : data;\n    }\n    if (typeof data === \"object\" && data !== null) {\n      const result = {};\n      for (const key in data) {\n        result[key] = this.sanitizeData(data[key]);\n      }\n      return result;\n    }\n    return data;\n  }\n  enqueue(event) {\n    this.queue.push(event);\n    this.persistQueue();\n    if (this.queue.length >= MAX_BATCH_SIZE) {\n      this.flush();\n    } else if (!this.timer) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  async flush() {\n    this.clearTimer();\n    if (this.queue.length === 0) {\n      return;\n    }\n    const events = this.queue.slice(0, MAX_BATCH_SIZE);\n    this.queue = this.queue.slice(MAX_BATCH_SIZE);\n    this.persistQueue();\n    try {\n      await this.httpClient.post(`/api/analytics/${this.projectId}/log`, { events });\n    } catch (error) {\n      this.queue = [...events, ...this.queue];\n      this.persistQueue();\n      console.error(\"Failed to send analytics events:\", error);\n    }\n    if (this.queue.length > 0) {\n      this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n    }\n  }\n  clearTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n  getOrCreateSessionId() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Session\"));\n      if (stored) {\n        const session = JSON.parse(stored);\n        const now = Date.now();\n        if (now - session.lastActivityAt > SESSION_DURATION) {\n          return this.createNewSession();\n        }\n        session.lastActivityAt = now;\n        localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n        return session.id;\n      }\n      return this.createNewSession();\n    } catch {\n      return null;\n    }\n  }\n  createNewSession() {\n    const now = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 10);\n    const session = {\n      id: `sess_${now}_${randomId}`,\n      startedAt: now,\n      lastActivityAt: now\n    };\n    try {\n      localStorage.setItem(this.getStorageKey(\"Session\"), JSON.stringify(session));\n    } catch {\n    }\n    return session.id;\n  }\n  loadQueue() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Queue\"));\n      if (stored) {\n        this.queue = JSON.parse(stored);\n        if (this.queue.length > 0) {\n          this.timer = setTimeout(() => this.flush(), BATCH_TIMEOUT);\n        }\n      }\n    } catch {\n      this.queue = [];\n    }\n  }\n  persistQueue() {\n    try {\n      if (this.queue.length === 0) {\n        localStorage.removeItem(this.getStorageKey(\"Queue\"));\n      } else {\n        localStorage.setItem(this.getStorageKey(\"Queue\"), JSON.stringify(this.queue));\n      }\n    } catch {\n    }\n  }\n  trackPageview() {\n    if (!this.hasTrackedPageview) {\n      this.log(\"pageview\");\n      this.hasTrackedPageview = true;\n    }\n  }\n  setupRouteChangeListener() {\n    if (!window.__blinkAnalyticsSetup) {\n      const originalPushState = history.pushState;\n      const originalReplaceState = history.replaceState;\n      const analyticsInstances = /* @__PURE__ */ new Set();\n      window.__blinkAnalyticsInstances = analyticsInstances;\n      history.pushState = (...args) => {\n        originalPushState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      history.replaceState = (...args) => {\n        originalReplaceState.apply(history, args);\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      };\n      window.addEventListener(\"popstate\", () => {\n        analyticsInstances.forEach((instance) => {\n          if (instance.isEnabled()) {\n            instance.log(\"pageview\");\n          }\n        });\n      });\n      window.__blinkAnalyticsSetup = true;\n    }\n    window.__blinkAnalyticsInstances?.add(this);\n  }\n  setupUnloadListener() {\n    window.addEventListener(\"pagehide\", () => {\n      this.flush();\n    });\n    window.addEventListener(\"unload\", () => {\n      this.flush();\n    });\n  }\n  captureUTMParams() {\n    const urlParams = new URLSearchParams(window.location.search);\n    this.utmParams = {\n      utm_source: urlParams.get(\"utm_source\"),\n      utm_medium: urlParams.get(\"utm_medium\"),\n      utm_campaign: urlParams.get(\"utm_campaign\"),\n      utm_content: urlParams.get(\"utm_content\"),\n      utm_term: urlParams.get(\"utm_term\")\n    };\n    const hasNewParams = Object.values(this.utmParams).some((v) => v !== null);\n    if (hasNewParams) {\n      this.persistAttribution();\n    }\n  }\n  loadPersistedAttribution() {\n    try {\n      const stored = localStorage.getItem(this.getStorageKey(\"Attribution\"));\n      if (stored) {\n        this.persistedAttribution = JSON.parse(stored);\n      }\n    } catch {\n      this.persistedAttribution = {};\n    }\n  }\n  persistAttribution() {\n    try {\n      const attribution = {\n        ...this.persistedAttribution,\n        ...Object.fromEntries(\n          Object.entries(this.utmParams).filter(([_, v]) => v !== null)\n        )\n      };\n      localStorage.setItem(this.getStorageKey(\"Attribution\"), JSON.stringify(attribution));\n      this.persistedAttribution = attribution;\n    } catch {\n    }\n  }\n  detectChannel() {\n    const referrer = document.referrer;\n    const utmMedium = this.utmParams.utm_medium;\n    this.utmParams.utm_source;\n    if (utmMedium) {\n      if (utmMedium === \"cpc\" || utmMedium === \"ppc\") return \"Paid Search\";\n      if (utmMedium === \"email\") return \"Email\";\n      if (utmMedium === \"social\") return \"Social\";\n      if (utmMedium === \"referral\") return \"Referral\";\n      if (utmMedium === \"display\") return \"Display\";\n      if (utmMedium === \"affiliate\") return \"Affiliate\";\n    }\n    if (!referrer) return \"Direct\";\n    try {\n      const referrerUrl = new URL(referrer);\n      const referrerDomain = referrerUrl.hostname.toLowerCase();\n      if (/google\\.|bing\\.|yahoo\\.|duckduckgo\\.|baidu\\.|yandex\\./.test(referrerDomain)) {\n        return \"Organic Search\";\n      }\n      if (/facebook\\.|twitter\\.|linkedin\\.|instagram\\.|youtube\\.|tiktok\\.|reddit\\./.test(referrerDomain)) {\n        return \"Social\";\n      }\n      if (/mail\\.|outlook\\.|gmail\\./.test(referrerDomain)) {\n        return \"Email\";\n      }\n      return \"Referral\";\n    } catch {\n      return \"Direct\";\n    }\n  }\n};\n\n// src/client.ts\nvar BlinkClientImpl = class {\n  auth;\n  db;\n  storage;\n  ai;\n  data;\n  realtime;\n  notifications;\n  analytics;\n  httpClient;\n  constructor(config) {\n    this.auth = new BlinkAuth(config);\n    this.httpClient = new HttpClient(\n      config,\n      () => this.auth.getToken(),\n      () => this.auth.getValidToken()\n    );\n    this.db = new BlinkDatabase(this.httpClient);\n    this.storage = new BlinkStorageImpl(this.httpClient);\n    this.ai = new BlinkAIImpl(this.httpClient);\n    this.data = new BlinkDataImpl(this.httpClient, config.projectId);\n    this.realtime = new BlinkRealtimeImpl(this.httpClient, config.projectId);\n    this.notifications = new BlinkNotificationsImpl(this.httpClient);\n    this.analytics = new BlinkAnalyticsImpl(this.httpClient, config.projectId);\n    this.auth.onAuthStateChanged((state) => {\n      if (state.isAuthenticated && state.user) {\n        this.analytics.setUserId(state.user.id);\n        this.analytics.setUserEmail(state.user.email);\n      } else {\n        this.analytics.setUserId(null);\n        this.analytics.setUserEmail(null);\n      }\n    });\n  }\n};\nfunction createClient(config) {\n  if (!config.projectId) {\n    throw new Error(\"projectId is required\");\n  }\n  return new BlinkClientImpl(config);\n}\n\nexport { BlinkAIImpl, BlinkAnalyticsImpl, BlinkDataImpl, BlinkDatabase, BlinkRealtimeChannel, BlinkRealtimeImpl, BlinkStorageImpl, BlinkTable, createClient };\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map"],
  "mappings": ";;;;;AAAA,IAAIA,cAA6B,CAAC,MAAM,OAAO,cAAY,cAAc,YAAU,OAAO,UAAU,cAAc,IAAI,MAAM,GAAG;AAAA,EAC7H,KAAK,CAAC,GAAG,OAAO,OAAO,cAAY,cAAc,YAAU,GAAG,CAAC;AACjE,CAAC,IAAI,GAAG,SAAS,GAAG;AAClB,MAAI,OAAO,cAAY,YAAa,QAAO,UAAQ,MAAM,MAAM,SAAS;AACxE,QAAM,MAAM,yBAAyB,IAAI,oBAAoB;AAC/D,CAAC;AAGD,IAAI,aAAa,cAAc,MAAM;AAAA,EACnC,YAAY,SAAS,MAAM,QAAQ,SAAS;AAC1C,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,iBAAiB,cAAc,WAAW;AAAA,EAC5C;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,MAAM,SAAS,aAAa,SAAS;AAC/C,UAAM,SAAS,MAAM,KAAK,OAAO;AACjC,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,YAAY,CAAC,iBAAiB,cAAc,EAAE,SAAS,IAAI;AAChE,SAAK,cAAc,eAAe,KAAK,sBAAsB,IAAI;AAAA,EACnE;AAAA,EACA,sBAAsB,MAAM;AAC1B,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AACF;AACA,IAAI,oBAAoB,cAAc,WAAW;AAAA,EAC/C,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,iBAAiB,QAAQ,OAAO;AAC/C,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,uBAAuB,cAAc,WAAW;AAAA,EAClD,YAAY,SAAS,SAAS;AAC5B,UAAM,SAAS,oBAAoB,KAAK,OAAO;AAC/C,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,oBAAoB,cAAc,WAAW;AAAA,EAC/C,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,iBAAiB,QAAQ,OAAO;AAC/C,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,eAAe,cAAc,WAAW;AAAA,EAC1C,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,YAAY,QAAQ,OAAO;AAC1C,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,iBAAiB,cAAc,WAAW;AAAA,EAC5C,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,cAAc,QAAQ,OAAO;AAC5C,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,qBAAqB,cAAc,WAAW;AAAA,EAChD,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,kBAAkB,QAAQ,OAAO;AAChD,SAAK,OAAO;AAAA,EACd;AACF;AACA,IAAI,0BAA0B,cAAc,WAAW;AAAA,EACrD,YAAY,SAAS,QAAQ,SAAS;AACpC,UAAM,SAAS,uBAAuB,QAAQ,OAAO;AACrD,SAAK,OAAO;AAAA,EACd;AACF;AAGA,SAAS,aAAa,KAAK;AACzB,SAAO,IAAI,QAAQ,UAAU,CAAC,WAAW,IAAI,OAAO,YAAY,CAAC,EAAE;AACrE;AACA,SAAS,6BAA6B,WAAW;AAC/C,MAAI,CAAC,UAAW,QAAO;AACvB,MAAI,SAAS,WAAW;AACtB,WAAO;AAAA,MACL,KAAK,UAAU,KAAK,IAAI,4BAA4B;AAAA,IACtD;AAAA,EACF;AACA,MAAI,QAAQ,WAAW;AACrB,WAAO;AAAA,MACL,IAAI,UAAU,IAAI,IAAI,4BAA4B;AAAA,IACpD;AAAA,EACF;AACA,QAAM,YAAY,CAAC;AACnB,aAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACtD,UAAM,aAAa,aAAa,KAAK;AACrC,cAAU,UAAU,IAAI;AAAA,EAC1B;AACA,SAAO;AACT;AACA,SAAS,iBAAiB,WAAW;AACnC,MAAI,CAAC,UAAW,QAAO;AACvB,MAAI,SAAS,WAAW;AACtB,UAAM,gBAAgB,UAAU,KAAK,IAAI,gBAAgB,EAAE,OAAO,OAAO,KAAK,CAAC;AAC/E,WAAO,cAAc,SAAS,IAAI,QAAQ,cAAc,KAAK,GAAG,CAAC,MAAM;AAAA,EACzE;AACA,MAAI,QAAQ,WAAW;AACrB,UAAM,eAAe,UAAU,IAAI,IAAI,gBAAgB,EAAE,OAAO,OAAO,KAAK,CAAC;AAC7E,WAAO,aAAa,SAAS,IAAI,OAAO,aAAa,KAAK,GAAG,CAAC,MAAM;AAAA,EACtE;AACA,QAAM,SAAS,CAAC;AAChB,aAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACtD,QAAI,UAAU,UAAU,UAAU,KAAM;AACxC,QAAI,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,GAAG;AACtD,iBAAW,CAAC,UAAU,aAAa,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC7D,cAAM,QAAQ,mBAAmB,OAAO,UAAU,aAAa;AAC/D,YAAI,MAAO,QAAO,KAAK,KAAK;AAAA,MAC9B;AAAA,IACF,OAAO;AACL,aAAO,KAAK,GAAG,KAAK,OAAO,iBAAiB,KAAK,CAAC,EAAE;AAAA,IACtD;AAAA,EACF;AACA,SAAO,OAAO,KAAK,GAAG;AACxB;AACA,SAAS,mBAAmB,OAAO,UAAU,OAAO;AAClD,UAAQ,UAAU;AAAA,IAChB,KAAK;AACH,aAAO,GAAG,KAAK,OAAO,iBAAiB,KAAK,CAAC;AAAA,IAC/C,KAAK;AACH,aAAO,GAAG,KAAK,QAAQ,iBAAiB,KAAK,CAAC;AAAA,IAChD,KAAK;AACH,aAAO,GAAG,KAAK,OAAO,iBAAiB,KAAK,CAAC;AAAA,IAC/C,KAAK;AACH,aAAO,GAAG,KAAK,QAAQ,iBAAiB,KAAK,CAAC;AAAA,IAChD,KAAK;AACH,aAAO,GAAG,KAAK,OAAO,iBAAiB,KAAK,CAAC;AAAA,IAC/C,KAAK;AACH,aAAO,GAAG,KAAK,QAAQ,iBAAiB,KAAK,CAAC;AAAA,IAChD,KAAK;AACH,aAAO,GAAG,KAAK,SAAS,iBAAiB,KAAK,CAAC;AAAA,IACjD,KAAK;AACH,aAAO,GAAG,KAAK,UAAU,iBAAiB,KAAK,CAAC;AAAA,IAClD,KAAK;AACH,aAAO,GAAG,KAAK,OAAO,UAAU,OAAO,SAAS,iBAAiB,KAAK,CAAC;AAAA,IACzE,KAAK;AACH,aAAO,GAAG,KAAK,QAAQ,iBAAiB,KAAK,CAAC;AAAA,IAChD,KAAK;AACH,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,cAAM,SAAS,MAAM,IAAI,gBAAgB,EAAE,KAAK,GAAG;AACnD,eAAO,GAAG,KAAK,QAAQ,MAAM;AAAA,MAC/B;AACA,aAAO;AAAA,IACT,KAAK;AACH,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,cAAM,SAAS,MAAM,IAAI,gBAAgB,EAAE,KAAK,GAAG;AACnD,eAAO,GAAG,KAAK,YAAY,MAAM;AAAA,MACnC;AACA,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AACA,SAAS,iBAAiB,OAAO;AAC/B,MAAI,UAAU,KAAM,QAAO;AAC3B,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO,QAAQ,MAAM;AAAA,EACvB;AACA,MAAI,OAAO,UAAU,SAAU,QAAO,MAAM,SAAS;AACrD,SAAO,mBAAmB,OAAO,KAAK,CAAC;AACzC;AACA,SAAS,WAAW,UAAU,CAAC,GAAG;AAChC,QAAM,SAAS,CAAC;AAChB,MAAI,QAAQ,UAAU,QAAQ,OAAO,SAAS,GAAG;AAC/C,UAAM,cAAc,QAAQ,OAAO,IAAI,YAAY;AACnD,WAAO,SAAS,YAAY,KAAK,GAAG;AAAA,EACtC,OAAO;AACL,WAAO,SAAS;AAAA,EAClB;AACA,MAAI,QAAQ,OAAO;AACjB,UAAM,iBAAiB,6BAA6B,QAAQ,KAAK;AACjE,UAAM,cAAc,iBAAiB,cAAc;AACnD,QAAI,aAAa;AACf,YAAM,eAAe,YAAY,MAAM,GAAG;AAC1C,iBAAW,SAAS,cAAc;AAChC,cAAM,CAAC,KAAK,KAAK,IAAI,MAAM,MAAM,KAAK,CAAC;AACvC,YAAI,OAAO,OAAO;AAChB,iBAAO,GAAG,IAAI;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,QAAQ,SAAS;AACnB,QAAI,OAAO,QAAQ,YAAY,UAAU;AACvC,aAAO,QAAQ,QAAQ;AAAA,IACzB,OAAO;AACL,YAAM,eAAe,OAAO,QAAQ,QAAQ,OAAO,EAAE,IAAI,CAAC,CAAC,OAAO,SAAS,MAAM,GAAG,aAAa,KAAK,CAAC,IAAI,SAAS,EAAE;AACtH,aAAO,QAAQ,aAAa,KAAK,GAAG;AAAA,IACtC;AAAA,EACF;AACA,MAAI,QAAQ,UAAU,QAAQ;AAC5B,WAAO,QAAQ,QAAQ,MAAM,SAAS;AAAA,EACxC;AACA,MAAI,QAAQ,WAAW,QAAQ;AAC7B,WAAO,SAAS,QAAQ,OAAO,SAAS;AAAA,EAC1C;AACA,MAAI,QAAQ,QAAQ;AAClB,WAAO,SAAS,QAAQ;AAAA,EAC1B;AACA,SAAO;AACT;AAGA,SAAS,cAAc,KAAK;AAC1B,SAAO,IAAI,QAAQ,UAAU,CAAC,WAAW,IAAI,OAAO,YAAY,CAAC,EAAE;AACrE;AACA,SAAS,aAAa,KAAK;AACzB,SAAO,IAAI,QAAQ,aAAa,CAAC,GAAG,WAAW,OAAO,YAAY,CAAC;AACrE;AACA,SAAS,uBAAuB,KAAK;AACnC,MAAI,QAAQ,QAAQ,QAAQ,OAAQ,QAAO;AAC3C,MAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,MAAI,MAAM,QAAQ,GAAG,EAAG,QAAO,IAAI,IAAI,sBAAsB;AAC7D,QAAM,YAAY,CAAC;AACnB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC9C,UAAM,WAAW,cAAc,GAAG;AAClC,cAAU,QAAQ,IAAI,uBAAuB,KAAK;AAAA,EACpD;AACA,SAAO;AACT;AACA,SAAS,uBAAuB,KAAK;AACnC,MAAI,QAAQ,QAAQ,QAAQ,OAAQ,QAAO;AAC3C,MAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,MAAI,MAAM,QAAQ,GAAG,EAAG,QAAO,IAAI,IAAI,sBAAsB;AAC7D,QAAM,YAAY,CAAC;AACnB,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC9C,UAAM,WAAW,aAAa,GAAG;AACjC,cAAU,QAAQ,IAAI,uBAAuB,KAAK;AAAA,EACpD;AACA,SAAO;AACT;AACA,IAAI,aAAa,MAAM;AAAA,EACrB,UAAU;AAAA,EACV,UAAU;AAAA,EACV;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,QAAQ,UAAU,eAAe;AAC3C,SAAK,YAAY,OAAO;AACxB,SAAK,WAAW;AAChB,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,QAAQ,MAAM,UAAU,CAAC,GAAG;AAChC,UAAM,MAAM,KAAK,SAAS,MAAM,QAAQ,YAAY;AACpD,UAAM,QAAQ,KAAK,gBAAgB,MAAM,KAAK,cAAc,IAAI,KAAK,SAAS;AAC9E,UAAM,UAAU;AAAA,MACd,gBAAgB;AAAA,MAChB,GAAG,QAAQ;AAAA,IACb;AACA,QAAI,OAAO;AACT,cAAQ,gBAAgB,UAAU,KAAK;AAAA,IACzC;AACA,UAAM,cAAc;AAAA,MAClB,QAAQ,QAAQ,UAAU;AAAA,MAC1B;AAAA,MACA,QAAQ,QAAQ;AAAA,IAClB;AACA,QAAI,QAAQ,QAAQ,QAAQ,WAAW,OAAO;AAC5C,kBAAY,OAAO,OAAO,QAAQ,SAAS,WAAW,QAAQ,OAAO,KAAK,UAAU,QAAQ,IAAI;AAAA,IAClG;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK,WAAW;AAC7C,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,KAAK,oBAAoB,QAAQ;AAAA,MACzC;AACA,YAAM,OAAO,MAAM,KAAK,cAAc,QAAQ;AAC9C,aAAO;AAAA,QACL;AAAA,QACA,QAAQ,SAAS;AAAA,QACjB,SAAS,SAAS;AAAA,MACpB;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAY;AAC/B,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACnF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,IAAI,MAAM,cAAc;AAC5B,WAAO,KAAK,QAAQ,MAAM,EAAE,QAAQ,OAAO,aAAa,CAAC;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,KAAK,MAAM,MAAM,SAAS;AAC9B,WAAO,KAAK,QAAQ,MAAM,EAAE,QAAQ,QAAQ,MAAM,QAAQ,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,MAAM,MAAM,MAAM,SAAS;AAC/B,WAAO,KAAK,QAAQ,MAAM,EAAE,QAAQ,SAAS,MAAM,QAAQ,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,MAAM,cAAc;AAC/B,WAAO,KAAK,QAAQ,MAAM,EAAE,QAAQ,UAAU,aAAa,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,OAAO,cAAc;AAC/B,UAAM,WAAW,MAAM,KAAK,IAAI,WAAW,KAAK,SAAS,YAAY,KAAK,IAAI,YAAY;AAC1F,UAAM,gBAAgB,uBAAuB,SAAS,IAAI;AAC1D,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,MAAM,OAAO,OAAO,MAAM,UAAU,CAAC,GAAG;AACtC,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ,WAAW;AACrB,cAAQ,SAAS;AAAA,IACnB;AACA,UAAM,gBAAgB,uBAAuB,IAAI;AACjD,UAAM,WAAW,MAAM,KAAK,KAAK,WAAW,KAAK,SAAS,YAAY,KAAK,IAAI,eAAe,OAAO;AACrG,UAAM,gBAAgB,uBAAuB,SAAS,IAAI;AAC1D,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,MAAM,QAAQ,OAAO,MAAM,cAAc,UAAU,CAAC,GAAG;AACrD,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ,WAAW;AACrB,cAAQ,SAAS;AAAA,IACnB;AACA,UAAM,gBAAgB,uBAAuB,IAAI;AACjD,UAAM,WAAW,MAAM,KAAK,QAAQ,WAAW,KAAK,SAAS,YAAY,KAAK,IAAI;AAAA,MAChF,QAAQ;AAAA,MACR,MAAM;AAAA,MACN;AAAA,MACA;AAAA,IACF,CAAC;AACD,UAAM,gBAAgB,uBAAuB,SAAS,IAAI;AAC1D,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,MAAM,SAAS,OAAO,cAAc,UAAU,CAAC,GAAG;AAChD,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ,WAAW;AACrB,cAAQ,SAAS;AAAA,IACnB;AACA,UAAM,WAAW,MAAM,KAAK,QAAQ,WAAW,KAAK,SAAS,YAAY,KAAK,IAAI;AAAA,MAChF,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF,CAAC;AACD,UAAM,gBAAgB,uBAAuB,SAAS,IAAI;AAC1D,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAEA,MAAM,MAAM,OAAO,QAAQ;AACzB,UAAM,WAAW,MAAM,KAAK,KAAK,WAAW,KAAK,SAAS,QAAQ,EAAE,OAAO,OAAO,CAAC;AACnF,UAAM,gBAAgB;AAAA,MACpB,GAAG,SAAS;AAAA,MACZ,MAAM,uBAAuB,SAAS,KAAK,IAAI;AAAA,IACjD;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAEA,MAAM,QAAQ,YAAY,OAAO,SAAS;AACxC,UAAM,WAAW,MAAM,KAAK,KAAK,WAAW,KAAK,SAAS,UAAU,EAAE,YAAY,KAAK,CAAC;AACxF,UAAM,gBAAgB;AAAA,MACpB,GAAG,SAAS;AAAA,MACZ,SAAS,SAAS,KAAK,QAAQ,IAAI,CAAC,YAAY;AAAA,QAC9C,GAAG;AAAA,QACH,MAAM,uBAAuB,OAAO,IAAI;AAAA,MAC1C,EAAE;AAAA,IACJ;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW,MAAM,MAAM,UAAU,UAAU,CAAC,GAAG;AACnD,UAAM,MAAM,KAAK,SAAS,IAAI;AAC9B,UAAM,QAAQ,KAAK,gBAAgB,MAAM,KAAK,cAAc,IAAI,KAAK,SAAS;AAC9E,UAAM,WAAW,IAAI,SAAS;AAC9B,QAAI,gBAAgB,MAAM;AACxB,eAAS,OAAO,QAAQ,IAAI;AAAA,IAC9B,WAAW,gBAAgB,MAAM;AAC/B,YAAM,eAAe,QAAQ,cAAc,IAAI,KAAK,CAAC,IAAI,GAAG,EAAE,MAAM,QAAQ,YAAY,CAAC,IAAI;AAC7F,eAAS,OAAO,QAAQ,YAAY;AAAA,IACtC,WAAW,OAAO,WAAW,eAAe,gBAAgB,QAAQ;AAClE,YAAM,OAAO,IAAI,KAAK,CAAC,IAAI,GAAG,EAAE,MAAM,QAAQ,eAAe,2BAA2B,CAAC;AACzF,eAAS,OAAO,QAAQ,IAAI;AAAA,IAC9B,OAAO;AACL,YAAM,IAAI,qBAAqB,uBAAuB;AAAA,IACxD;AACA,aAAS,OAAO,QAAQ,QAAQ;AAChC,QAAI,QAAQ,WAAW,QAAQ;AAC7B,eAAS,OAAO,WAAW,KAAK,UAAU,EAAE,QAAQ,QAAQ,OAAO,CAAC,CAAC;AAAA,IACvE;AACA,UAAM,UAAU,CAAC;AACjB,QAAI,OAAO;AACT,cAAQ,gBAAgB,UAAU,KAAK;AAAA,IACzC;AACA,QAAI;AACF,UAAI,OAAO,mBAAmB,eAAe,QAAQ,YAAY;AAC/D,eAAO,KAAK,mBAAmB,KAAK,UAAU,SAAS,QAAQ,UAAU;AAAA,MAC3E;AACA,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,KAAK,oBAAoB,QAAQ;AAAA,MACzC;AACA,YAAM,OAAO,MAAM,KAAK,cAAc,QAAQ;AAC9C,aAAO;AAAA,QACL;AAAA,QACA,QAAQ,SAAS;AAAA,QACjB,SAAS,SAAS;AAAA,MACpB;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAY;AAC/B,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,uBAAuB,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC/E;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB,KAAK,UAAU,SAAS,YAAY;AACrD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,MAAM,IAAI,eAAe;AAC/B,UAAI,OAAO,iBAAiB,YAAY,CAAC,UAAU;AACjD,YAAI,MAAM,kBAAkB;AAC1B,gBAAM,UAAU,KAAK,MAAM,MAAM,SAAS,MAAM,QAAQ,GAAG;AAC3D,qBAAW,OAAO;AAAA,QACpB;AAAA,MACF,CAAC;AACD,UAAI,iBAAiB,QAAQ,YAAY;AACvC,YAAI,IAAI,UAAU,OAAO,IAAI,SAAS,KAAK;AACzC,cAAI;AACF,kBAAM,OAAO,KAAK,MAAM,IAAI,YAAY;AACxC,oBAAQ;AAAA,cACN;AAAA,cACA,QAAQ,IAAI;AAAA,cACZ,SAAS,IAAI,QAAQ;AAAA;AAAA,YAEvB,CAAC;AAAA,UACH,SAAS,OAAO;AACd,mBAAO,IAAI,kBAAkB,4BAA4B,IAAI,MAAM,CAAC;AAAA,UACtE;AAAA,QACF,OAAO;AACL,cAAI;AACF,kBAAM,YAAY,KAAK,MAAM,IAAI,YAAY;AAC7C,kBAAM,UAAU,UAAU,OAAO,WAAW,UAAU,WAAW,QAAQ,IAAI,MAAM;AACnF,oBAAQ,IAAI,QAAQ;AAAA,cAClB,KAAK;AACH,uBAAO,IAAI,eAAe,SAAS,SAAS,CAAC;AAC7C;AAAA,cACF,KAAK;AACH,uBAAO,IAAI,qBAAqB,SAAS,SAAS,CAAC;AACnD;AAAA,cACF;AACE,uBAAO,IAAI,kBAAkB,SAAS,IAAI,QAAQ,SAAS,CAAC;AAAA,YAChE;AAAA,UACF,QAAQ;AACN,mBAAO,IAAI,kBAAkB,QAAQ,IAAI,MAAM,IAAI,IAAI,MAAM,CAAC;AAAA,UAChE;AAAA,QACF;AAAA,MACF,CAAC;AACD,UAAI,iBAAiB,SAAS,MAAM;AAClC,eAAO,IAAI,kBAAkB,kCAAkC,CAAC;AAAA,MAClE,CAAC;AACD,UAAI,KAAK,QAAQ,GAAG;AACpB,aAAO,QAAQ,OAAO,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAChD,YAAI,iBAAiB,KAAK,KAAK;AAAA,MACjC,CAAC;AACD,UAAI,KAAK,QAAQ;AAAA,IACnB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,QAAQ,UAAU,CAAC,GAAG;AACjC,UAAM,EAAE,QAAQ,GAAG,KAAK,IAAI;AAC5B,UAAM,cAAc,EAAE,GAAG,KAAK;AAC9B,QAAI,QAAQ;AACV,kBAAY,SAAS;AAAA,IACvB;AACA,WAAO,KAAK,QAAQ,WAAW,KAAK,SAAS,SAAS;AAAA,MACpD,QAAQ;AAAA,MACR,MAAM;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,aAAa,QAAQ,UAAU,CAAC,GAAG,SAAS;AAChD,UAAM,MAAM,KAAK,SAAS,WAAW,KAAK,SAAS,OAAO;AAC1D,UAAM,QAAQ,KAAK,gBAAgB,MAAM,KAAK,cAAc,IAAI,KAAK,SAAS;AAC9E,UAAM,UAAU;AAAA,MACd,gBAAgB;AAAA,IAClB;AACA,QAAI,OAAO;AACT,cAAQ,gBAAgB,UAAU,KAAK;AAAA,IACzC;AACA,UAAM,OAAO;AAAA,MACX;AAAA,MACA,QAAQ;AAAA,MACR,GAAG;AAAA,IACL;AACA,UAAM,EAAE,QAAQ,SAAS,GAAG,SAAS,IAAI;AACzC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,QAAQ;AAAA,QAC7B,QAAQ,QAAQ;AAAA,MAClB,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,KAAK,oBAAoB,QAAQ;AAAA,MACzC;AACA,UAAI,CAAC,SAAS,MAAM;AAClB,cAAM,IAAI,kBAAkB,gCAAgC;AAAA,MAC9D;AACA,aAAO,KAAK,gBAAgB,SAAS,MAAM,OAAO;AAAA,IACpD,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAY;AAC/B,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACrF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,SAAS,QAAQ,UAAU,CAAC,GAAG;AACnC,UAAM,EAAE,QAAQ,GAAG,KAAK,IAAI;AAC5B,UAAM,cAAc,EAAE,GAAG,KAAK;AAC9B,QAAI,QAAQ;AACV,kBAAY,SAAS;AAAA,IACvB;AACA,WAAO,KAAK,QAAQ,WAAW,KAAK,SAAS,WAAW;AAAA,MACtD,QAAQ;AAAA,MACR,MAAM;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,eAAe,QAAQ,UAAU,CAAC,GAAG,WAAW;AACpD,UAAM,MAAM,KAAK,SAAS,WAAW,KAAK,SAAS,SAAS;AAC5D,UAAM,QAAQ,KAAK,gBAAgB,MAAM,KAAK,cAAc,IAAI,KAAK,SAAS;AAC9E,UAAM,UAAU;AAAA,MACd,gBAAgB;AAAA,IAClB;AACA,QAAI,OAAO;AACT,cAAQ,gBAAgB,UAAU,KAAK;AAAA,IACzC;AACA,UAAM,OAAO;AAAA,MACX;AAAA,MACA,QAAQ;AAAA,MACR,GAAG;AAAA,IACL;AACA,UAAM,EAAE,QAAQ,UAAU,GAAG,UAAU,IAAI;AAC3C,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR;AAAA,QACA,MAAM,KAAK,UAAU,SAAS;AAAA,QAC9B,QAAQ,QAAQ;AAAA,MAClB,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,KAAK,oBAAoB,QAAQ;AAAA,MACzC;AACA,UAAI,CAAC,SAAS,MAAM;AAClB,cAAM,IAAI,kBAAkB,gCAAgC;AAAA,MAC9D;AACA,aAAO,KAAK,gBAAgB,SAAS,MAAM,QAAQ,SAAS;AAAA,IAC9D,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAY;AAC/B,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACrF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,QAAQ,QAAQ,UAAU,CAAC,GAAG;AAClC,UAAM,EAAE,QAAQ,GAAG,KAAK,IAAI;AAC5B,WAAO,KAAK,QAAQ,WAAW,KAAK,SAAS,UAAU;AAAA,MACrD,QAAQ;AAAA,MACR,MAAM;AAAA,QACJ;AAAA,QACA,GAAG;AAAA,MACL;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,MAAM,SAAS,MAAM,UAAU,CAAC,GAAG;AACjC,UAAM,EAAE,QAAQ,GAAG,KAAK,IAAI;AAC5B,WAAO,KAAK,QAAQ,WAAW,KAAK,SAAS,WAAW;AAAA,MACtD,QAAQ;AAAA,MACR,MAAM;AAAA,QACJ;AAAA,QACA,GAAG;AAAA,MACL;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,MAAM,aAAa,OAAO,UAAU,CAAC,GAAG;AACtC,UAAM,EAAE,QAAQ,GAAG,KAAK,IAAI;AAC5B,QAAI;AACJ,QAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,KAAK,GAAG;AACrD,qBAAe;AAAA,IACjB,WAAW,iBAAiB,YAAY;AACtC,qBAAe,MAAM,KAAK,KAAK;AAAA,IACjC,WAAW,iBAAiB,aAAa;AACvC,qBAAe,MAAM,KAAK,IAAI,WAAW,KAAK,CAAC;AAAA,IACjD,WAAW,OAAO,WAAW,eAAe,OAAO,SAAS,KAAK,GAAG;AAClE,qBAAe,MAAM,KAAK,IAAI,WAAW,KAAK,CAAC;AAAA,IACjD,OAAO;AACL,YAAM,IAAI,qBAAqB,8BAA8B;AAAA,IAC/D;AACA,WAAO,KAAK,QAAQ,WAAW,KAAK,SAAS,eAAe;AAAA,MAC1D,QAAQ;AAAA,MACR,MAAM;AAAA,QACJ,OAAO;AAAA,QACP,GAAG;AAAA,MACL;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,mBAAmB,WAAW,SAAS;AAC3C,WAAO,KAAK,QAAQ,aAAa,SAAS,qBAAqB;AAAA,MAC7D,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA,EACA,MAAM,oBAAoB,WAAW,MAAM,UAAU,WAAW;AAC9D,UAAM,WAAW,IAAI,SAAS;AAC9B,aAAS,OAAO,QAAQ,IAAI;AAC5B,QAAI,aAAa,QAAQ;AACvB,eAAS,OAAO,YAAY,OAAO,QAAQ,CAAC;AAAA,IAC9C;AACA,QAAI,cAAc,QAAQ;AACxB,eAAS,OAAO,aAAa,OAAO,SAAS,CAAC;AAAA,IAChD;AACA,WAAO,KAAK,QAAQ,aAAa,SAAS,sBAAsB;AAAA,MAC9D,QAAQ;AAAA,MACR,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AAAA,EACA,MAAM,WAAW,WAAW,SAAS;AACnC,WAAO,KAAK,QAAQ,aAAa,SAAS,WAAW;AAAA,MACnD,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA,EACA,MAAM,eAAe,WAAW,SAAS;AACvC,WAAO,KAAK,QAAQ,aAAa,SAAS,eAAe;AAAA,MACvD,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,OAAO;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA,EACA,MAAM,UAAU,WAAW,SAAS;AAClC,WAAO,KAAK,KAAK,aAAa,SAAS,UAAU,OAAO;AAAA,EAC1D;AAAA,EACA,MAAM,WAAW,WAAW,SAAS;AACnC,WAAO,KAAK,KAAK,aAAa,SAAS,WAAW,OAAO;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB,WAAW,SAAS;AACxC,WAAO,KAAK,KAAK,iBAAiB,SAAS,YAAY,OAAO;AAAA,EAChE;AAAA,EACA,MAAM,oBAAoB,WAAW,SAAS;AAC5C,WAAO,KAAK,IAAI,iBAAiB,SAAS,aAAa,EAAE,QAAQ,CAAC;AAAA,EACpE;AAAA,EACA,MAAM,oBAAoB,WAAW,SAAS;AAC5C,UAAM,EAAE,SAAS,GAAG,aAAa,IAAI;AACrC,WAAO,KAAK,IAAI,iBAAiB,SAAS,aAAa;AAAA,MACrD;AAAA,MACA,GAAG,OAAO;AAAA,QACR,OAAO,QAAQ,YAAY,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,MAAM,MAAM,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AAAA,MAC9F;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS,MAAM,cAAc;AAC3B,UAAM,UAAU,KAAK,SAAS,YAAY,IAAI,KAAK,UAAU,KAAK;AAClE,UAAM,MAAM,IAAI,IAAI,MAAM,OAAO;AACjC,QAAI,cAAc;AAChB,aAAO,QAAQ,YAAY,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACrD,YAAI,aAAa,IAAI,KAAK,KAAK;AAAA,MACjC,CAAC;AAAA,IACH;AACA,WAAO,IAAI,SAAS;AAAA,EACtB;AAAA,EACA,MAAM,cAAc,UAAU;AAC5B,UAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AACvD,QAAI,aAAa,SAAS,kBAAkB,GAAG;AAC7C,aAAO,SAAS,KAAK;AAAA,IACvB;AACA,QAAI,aAAa,SAAS,OAAO,GAAG;AAClC,aAAO,SAAS,KAAK;AAAA,IACvB;AACA,WAAO,SAAS,KAAK;AAAA,EACvB;AAAA,EACA,MAAM,oBAAoB,UAAU;AAClC,QAAI;AACJ,QAAI;AACF,YAAM,cAAc,SAAS,QAAQ,IAAI,cAAc;AACvD,UAAI,aAAa,SAAS,kBAAkB,GAAG;AAC7C,oBAAY,MAAM,SAAS,KAAK;AAAA,MAClC,OAAO;AACL,oBAAY,EAAE,SAAS,MAAM,SAAS,KAAK,EAAE;AAAA,MAC/C;AAAA,IACF,QAAQ;AACN,kBAAY,EAAE,SAAS,yBAAyB;AAAA,IAClD;AACA,UAAM,UAAU,UAAU,OAAO,WAAW,UAAU,WAAW,QAAQ,SAAS,MAAM;AACxF,cAAU,OAAO,QAAQ,UAAU;AACnC,YAAQ,SAAS,QAAQ;AAAA,MACvB,KAAK;AACH,cAAM,IAAI,eAAe,SAAS,SAAS;AAAA,MAC7C,KAAK;AACH,cAAM,IAAI,qBAAqB,SAAS,SAAS;AAAA,MACnD;AACE,cAAM,IAAI,kBAAkB,SAAS,SAAS,QAAQ,SAAS;AAAA,IACnE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,MAAM,SAAS,WAAW;AAC9C,UAAM,SAAS,KAAK,UAAU;AAC9B,UAAM,UAAU,IAAI,YAAY;AAChC,QAAI,SAAS;AACb,QAAI,cAAc,CAAC;AACnB,QAAI;AACF,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAI,KAAM;AACV,kBAAU,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAChD,cAAM,QAAQ,OAAO,MAAM,OAAO;AAClC,iBAAS,MAAM,IAAI,KAAK;AACxB,mBAAW,QAAQ,OAAO;AACxB,cAAI,CAAC,KAAK,KAAK,EAAG;AAClB,cAAI;AACF,gBAAI,KAAK,WAAW,IAAI,GAAG;AACzB,oBAAM,WAAW,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC;AACzC,0BAAY,YAAY,SAAS;AAAA,YACnC,WAAW,KAAK,WAAW,IAAI,GAAG;AAChC,oBAAM,YAAY,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC;AAC1C,kBAAI,SAAS;AACX,wBAAQ,SAAS;AAAA,cACnB;AACA,0BAAY,QAAQ,YAAY,QAAQ,MAAM;AAAA,YAChD,WAAW,KAAK,WAAW,IAAI,GAAG;AAChC,oBAAM,OAAO,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC;AACrC,kBAAI,MAAM,QAAQ,IAAI,KAAK,KAAK,SAAS,GAAG;AAC1C,sBAAM,OAAO,KAAK,CAAC;AACnB,oBAAI,OAAO,SAAS,UAAU;AAC5B,8BAAY,SAAS;AAAA,gBACvB,WAAW,OAAO,SAAS,UAAU;AACnC,sBAAI,WAAW;AACb,8BAAU,IAAI;AAAA,kBAChB;AACA,8BAAY,SAAS;AAAA,gBACvB;AAAA,cACF;AAAA,YACF,WAAW,KAAK,WAAW,IAAI,GAAG;AAChC,oBAAM,WAAW,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC;AACzC,kBAAI,SAAS,OAAO;AAClB,4BAAY,QAAQ,SAAS;AAAA,cAC/B;AACA,kBAAI,SAAS,cAAc;AACzB,4BAAY,eAAe,SAAS;AAAA,cACtC;AAAA,YACF,WAAW,KAAK,WAAW,IAAI,GAAG;AAChC,oBAAM,YAAY,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC;AAC1C,0BAAY,QAAQ;AAAA,YACtB;AAAA,UACF,SAAS,OAAO;AACd,oBAAQ,KAAK,gCAAgC,MAAM,KAAK;AAAA,UAC1D;AAAA,QACF;AAAA,MACF;AACA,UAAI,OAAO,KAAK,GAAG;AACjB,YAAI;AACF,cAAI,OAAO,WAAW,IAAI,GAAG;AAC3B,kBAAM,YAAY,KAAK,MAAM,OAAO,MAAM,CAAC,CAAC;AAC5C,gBAAI,SAAS;AACX,sBAAQ,SAAS;AAAA,YACnB;AACA,wBAAY,QAAQ,YAAY,QAAQ,MAAM;AAAA,UAChD,WAAW,OAAO,WAAW,IAAI,GAAG;AAClC,kBAAM,OAAO,KAAK,MAAM,OAAO,MAAM,CAAC,CAAC;AACvC,gBAAI,MAAM,QAAQ,IAAI,KAAK,KAAK,SAAS,GAAG;AAC1C,oBAAM,OAAO,KAAK,CAAC;AACnB,kBAAI,OAAO,SAAS,UAAU;AAC5B,oBAAI,WAAW;AACb,4BAAU,IAAI;AAAA,gBAChB;AACA,4BAAY,SAAS;AAAA,cACvB;AAAA,YACF;AAAA,UACF,WAAW,OAAO,WAAW,IAAI,GAAG;AAClC,kBAAM,WAAW,KAAK,MAAM,OAAO,MAAM,CAAC,CAAC;AAC3C,gBAAI,SAAS,OAAO;AAClB,0BAAY,QAAQ,SAAS;AAAA,YAC/B;AACA,gBAAI,SAAS,cAAc;AACzB,0BAAY,eAAe,SAAS;AAAA,YACtC;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd,kBAAQ,KAAK,iCAAiC,QAAQ,KAAK;AAAA,QAC7D;AAAA,MACF;AACA,aAAO;AAAA,IACT,UAAE;AACA,aAAO,YAAY;AAAA,IACrB;AAAA,EACF;AACF;AAGA,IAAI,YAAY,MAAM;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAA4B,oBAAI,IAAI;AAAA,EACpC;AAAA,EACA;AAAA,EACA,qBAAqB;AAAA,EACrB,WAAW;AAAA,EACX,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,YAAY,QAAQ;AAClB,SAAK,SAAS;AACd,QAAI,CAAC,OAAO,WAAW;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AACA,SAAK,aAAa;AAAA,MAChB,MAAM;AAAA;AAAA,MAEN,SAAS;AAAA,MACT,SAAS;AAAA,MACT,GAAG,OAAO;AAAA,IACZ;AACA,SAAK,UAAU,KAAK,WAAW,WAAW;AAC1C,SAAK,UAAU,KAAK,WAAW,WAAW;AAC1C,QAAI,OAAO,WAAW,eAAe,KAAK,YAAY,wBAAwB,OAAO,SAAS,aAAa,eAAe,OAAO,SAAS,aAAa,cAAc;AACnK,cAAQ,KAAK,mHAA6H;AAAA,IAC5I;AACA,QAAI,OAAO,iBAAiB,UAAU,CAAC,OAAO,MAAM,MAAM;AACxD,WAAK,WAAW,OAAO,OAAO,eAAe,YAAY;AAAA,IAC3D;AACA,SAAK,YAAY;AAAA,MACf,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb;AACA,QAAI,OAAO,WAAW,aAAa;AACjC,WAAK,WAAW,OAAO,SAAS,OAAO;AACvC,WAAK,0BAA0B;AAC/B,WAAK,kBAAkB;AACvB,WAAK,wBAAwB,KAAK,WAAW;AAAA,IAC/C,OAAO;AACL,WAAK,gBAAgB;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,QAAQ;AACpB,WAAO,SAAS,MAAM,IAAI,KAAK,OAAO,SAAS;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,wBAAwB;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,wBAAwB;AAC5B,QAAI,KAAK,cAAe;AACxB,QAAI,KAAK,uBAAuB;AAC9B,YAAM,KAAK;AAAA,IACb;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,4BAA4B;AAC1B,QAAI,CAAC,KAAK,SAAU;AACpB,WAAO,iBAAiB,WAAW,CAAC,UAAU;AAC5C,UAAI,MAAM,WAAW,uBAAuB,MAAM,WAAW,2BAA2B,MAAM,WAAW,yBAAyB;AAChI;AAAA,MACF;AACA,UAAI,MAAM,MAAM,SAAS,qBAAqB;AAC5C,gBAAQ,IAAI,4CAAmD;AAC/D,cAAM,EAAE,OAAO,IAAI,MAAM;AACzB,YAAI,QAAQ;AACV,eAAK,qBAAqB;AAC1B,eAAK,UAAU,QAAQ,KAAK,EAAE,KAAK,MAAM;AACvC,oBAAQ,IAAI,qCAA0C;AAAA,UACxD,CAAC,EAAE,MAAM,CAAC,UAAU;AAClB,oBAAQ,MAAM,yCAAyC,KAAK;AAAA,UAC9D,CAAC;AAAA,QACH;AAAA,MACF;AACA,UAAI,MAAM,MAAM,SAAS,qBAAqB;AAC5C,gBAAQ,IAAI,+CAAsD;AAClE,aAAK,YAAY;AAAA,MACnB;AAAA,IACF,CAAC;AACD,QAAI,OAAO,WAAW,QAAQ;AAC5B,cAAQ,IAAI,8CAAqD;AACjE,aAAO,OAAO,YAAY;AAAA,QACxB,MAAM;AAAA,QACN,WAAW,KAAK,OAAO;AAAA,MACzB,GAAG,GAAG;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,aAAa;AACjB,YAAQ,IAAI,+BAAsC;AAClD,SAAK,WAAW,IAAI;AACpB,QAAI;AACF,WAAK,sBAAsB;AAC3B,UAAI,KAAK,UAAU;AACjB,gBAAQ,IAAI,8DAAqE;AACjF,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,GAAG,CAAC;AACvD,YAAI,KAAK,oBAAoB;AAC3B,kBAAQ,IAAI,mCAAwC;AACpD,gBAAM,KAAK,UAAU,KAAK,oBAAoB,KAAK;AACnD;AAAA,QACF;AAAA,MACF;AACA,YAAM,gBAAgB,KAAK,qBAAqB;AAChD,UAAI,eAAe;AACjB,gBAAQ,IAAI,yCAAgD;AAC5D,cAAM,KAAK,UAAU,eAAe,IAAI;AACxC,aAAK,eAAe;AACpB,gBAAQ,IAAI,2CAAgD;AAC5D;AAAA,MACF;AACA,YAAM,eAAe,KAAK,gBAAgB;AAC1C,UAAI,cAAc;AAChB,gBAAQ,IAAI,yCAAgD;AAAA,UAC1D,gBAAgB,CAAC,CAAC,aAAa;AAAA,UAC/B,iBAAiB,CAAC,CAAC,aAAa;AAAA,UAChC,UAAU,aAAa;AAAA,UACvB,WAAW,aAAa;AAAA,UACxB,kBAAkB,aAAa;AAAA,UAC/B,aAAa,KAAK,MAAM,KAAK,IAAI,IAAI,GAAG;AAAA,QAC1C,CAAC;AACD,aAAK,UAAU,SAAS;AACxB,gBAAQ,IAAI,yDAAgE,CAAC,CAAC,KAAK,UAAU,QAAQ,aAAa;AAClH,cAAM,UAAU,MAAM,KAAK,qBAAqB,YAAY;AAC5D,YAAI,SAAS;AACX,kBAAQ,IAAI,+CAAoD;AAChE;AAAA,QACF,OAAO;AACL,kBAAQ,IAAI,uCAA8C;AAC1D,eAAK,YAAY;AAAA,QACnB;AAAA,MACF;AACA,cAAQ,IAAI,mBAAwB;AACpC,UAAI,KAAK,OAAO,cAAc;AAC5B,gBAAQ,IAAI,+CAAsD;AAClE,aAAK,eAAe;AAAA,MACtB,OAAO;AACL,gBAAQ,IAAI,yDAAmE;AAAA,MACjF;AAAA,IACF,UAAE;AACA,WAAK,WAAW,KAAK;AACrB,WAAK,gBAAgB;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS;AACb,QAAI,cAAc,WAAW,KAAK,WAAW;AAC7C,QAAI,CAAC,eAAe,OAAO,WAAW,aAAa;AACjD,UAAI,OAAO,SAAS,KAAK,WAAW,MAAM,GAAG;AAC3C,sBAAc,OAAO,SAAS;AAAA,MAChC,OAAO;AACL,sBAAc,GAAG,OAAO,SAAS,QAAQ,KAAK,OAAO,SAAS,IAAI,GAAG,OAAO,SAAS,QAAQ,GAAG,OAAO,SAAS,MAAM,GAAG,OAAO,SAAS,IAAI;AAAA,MAC/I;AAAA,IACF;AACA,QAAI,eAAe,OAAO,WAAW,aAAa;AAChD,UAAI;AACF,cAAM,MAAM,IAAI,IAAI,WAAW;AAC/B,YAAI,aAAa,OAAO,cAAc;AACtC,YAAI,aAAa,OAAO,UAAU;AAClC,sBAAc,IAAI,SAAS;AAAA,MAC7B,SAAS,GAAG;AACV,gBAAQ,KAAK,iCAAiC,CAAC;AAAA,MACjD;AAAA,IACF;AACA,UAAM,UAAU,IAAI,IAAI,SAAS,KAAK,OAAO;AAC7C,YAAQ,aAAa,IAAI,gBAAgB,eAAe,EAAE;AAC1D,QAAI,KAAK,OAAO,WAAW;AACzB,cAAQ,aAAa,IAAI,cAAc,KAAK,OAAO,SAAS;AAAA,IAC9D;AACA,QAAI,OAAO,WAAW,aAAa;AACjC,aAAO,SAAS,OAAO,QAAQ,SAAS;AAAA,IAC1C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,aAAa;AAClB,SAAK,YAAY;AACjB,QAAI,eAAe,OAAO,WAAW,aAAa;AAChD,aAAO,SAAS,OAAO;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB;AAChB,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW;AACT,WAAO,KAAK,UAAU,QAAQ,gBAAgB;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAIA,uBAAuB;AACrB,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,CAAC,UAAU,CAAC,OAAO,WAAW;AAChC,aAAO;AAAA,IACT;AACA,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAG;AACvC,UAAM,YAAY,OAAO,YAAY,OAAO;AAC5C,UAAM,aAAa;AACnB,WAAO,OAAO,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAIA,wBAAwB;AACtB,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,CAAC,UAAU,CAAC,OAAO,iBAAiB,CAAC,OAAO,aAAa,CAAC,OAAO,oBAAoB;AACvF,aAAO;AAAA,IACT;AACA,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAG;AACvC,UAAM,YAAY,OAAO,YAAY,OAAO;AAC5C,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB;AACpB,UAAM,SAAS,KAAK,UAAU;AAC9B,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,QAAI,CAAC,KAAK,qBAAqB,GAAG;AAChC,cAAQ,IAAI,+BAAoC;AAChD,aAAO,OAAO;AAAA,IAChB;AACA,YAAQ,IAAI,+CAAoD;AAChE,QAAI,KAAK,sBAAsB,GAAG;AAChC,cAAQ,IAAI,+CAAoD;AAChE,WAAK,YAAY;AACjB,UAAI,KAAK,OAAO,cAAc;AAC5B,aAAK,eAAe;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,UAAM,YAAY,MAAM,KAAK,aAAa;AAC1C,QAAI,WAAW;AACb,cAAQ,IAAI,gCAAqC;AACjD,aAAO,KAAK,UAAU,QAAQ,gBAAgB;AAAA,IAChD,OAAO;AACL,cAAQ,IAAI,wBAA6B;AACzC,WAAK,YAAY;AACjB,UAAI,KAAK,OAAO,cAAc;AAC5B,aAAK,eAAe;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK;AACT,UAAM,KAAK,sBAAsB;AACjC,QAAI,KAAK,UAAU,mBAAmB,KAAK,UAAU,MAAM;AACzD,aAAO,KAAK,UAAU;AAAA,IACxB;AACA,QAAI,CAAC,KAAK,UAAU,iBAAiB;AACnC,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAI,KAAK,UAAU,MAAM;AACvB,kBAAQ,KAAK,UAAU,IAAI;AAC3B;AAAA,QACF;AACA,cAAM,UAAU,WAAW,MAAM;AAC/B,sBAAY;AACZ,iBAAO,IAAI,eAAe,gBAAmC,4CAA4C,CAAC;AAAA,QAC5G,GAAG,GAAG;AACN,cAAM,cAAc,KAAK,mBAAmB,CAAC,UAAU;AACrD,cAAI,MAAM,MAAM;AACd,yBAAa,OAAO;AACpB,wBAAY;AACZ,oBAAQ,MAAM,IAAI;AAAA,UACpB,WAAW,CAAC,MAAM,aAAa,CAAC,MAAM,iBAAiB;AACrD,yBAAa,OAAO;AACpB,wBAAY;AACZ,mBAAO,IAAI,eAAe,uBAAiD,mBAAmB,CAAC;AAAA,UACjG;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AACA,QAAI,QAAQ,KAAK,SAAS;AAC1B,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,eAAe,iBAAqC,2BAA2B;AAAA,IAC3F;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,gBAAgB;AAAA,QAC1D,SAAS;AAAA,UACP,iBAAiB,UAAU,KAAK;AAAA,QAClC;AAAA,MACF,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,YAAI,SAAS,WAAW,KAAK;AAC3B,gBAAM,YAAY,MAAM,KAAK,aAAa;AAC1C,cAAI,WAAW;AACb,oBAAQ,KAAK,SAAS;AACtB,gBAAI,OAAO;AACT,oBAAM,gBAAgB,MAAM,MAAM,GAAG,KAAK,OAAO,gBAAgB;AAAA,gBAC/D,SAAS;AAAA,kBACP,iBAAiB,UAAU,KAAK;AAAA,gBAClC;AAAA,cACF,CAAC;AACD,kBAAI,cAAc,IAAI;AACpB,sBAAM,YAAY,MAAM,cAAc,KAAK;AAC3C,sBAAM,QAAQ,UAAU;AACxB,qBAAK,gBAAgB;AAAA,kBACnB,GAAG,KAAK;AAAA,kBACR,MAAM;AAAA,gBACR,CAAC;AACD,uBAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AACA,eAAK,YAAY;AACjB,cAAI,KAAK,OAAO,cAAc;AAC5B,iBAAK,eAAe;AAAA,UACtB;AAAA,QACF;AACA,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE;AACxD,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,yBAAyB,SAAS,UAAU,EAAE;AAAA,MACvG;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAM,OAAO,KAAK;AAClB,WAAK,gBAAgB;AAAA,QACnB,GAAG,KAAK;AAAA,QACR;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,MAAM;AACjB,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,2CAA2C;AAAA,IACvH;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,oBAAoB;AAAA,QAC9D,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,GAAG;AAAA,UACH,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,gBAAgB;AAAA,MACzE;AACA,YAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAM,KAAK,UAAU;AAAA,QACnB,cAAc,OAAO;AAAA,QACrB,eAAe,OAAO;AAAA,QACtB,YAAY,OAAO;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,oBAAoB,OAAO;AAAA,MAC7B,GAAG,IAAI;AACP,aAAO,OAAO;AAAA,IAChB,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB,OAAO,UAAU;AACrC,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,oDAAoD;AAAA,IAChI;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,0BAA0B;AAAA,QACpE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,gBAAgB;AAAA,MACzE;AACA,YAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAM,KAAK,UAAU;AAAA,QACnB,cAAc,OAAO;AAAA,QACrB,eAAe,OAAO;AAAA,QACtB,YAAY,OAAO;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,oBAAoB,OAAO;AAAA,MAC7B,GAAG,IAAI;AACP,aAAO,OAAO;AAAA,IAChB,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,iBAAiB,SAAS;AAC9B,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,qDAAqD;AAAA,IACjI;AACA,WAAO,KAAK,mBAAmB,UAAU,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,iBAAiB,SAAS;AAC9B,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,qDAAqD;AAAA,IACjI;AACA,WAAO,KAAK,mBAAmB,UAAU,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB,SAAS;AAC7B,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,oDAAoD;AAAA,IAChI;AACA,WAAO,KAAK,mBAAmB,SAAS,OAAO;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB,SAAS;AACjC,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,wDAAwD;AAAA,IACpI;AACA,WAAO,KAAK,mBAAmB,aAAa,OAAO;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,mBAAmB,UAAU,SAAS;AAC1C,QAAI,KAAK,WAAW,SAAS,YAAY;AACvC,YAAM,IAAI,eAAe,uBAAiD,uDAAuD;AAAA,IACnI;AACA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,QAAQ,KAAK,cAAc;AACjC,UAAI;AACF,YAAI,OAAO,WAAW,aAAa;AACjC,yBAAe,QAAQ,qBAAqB,KAAK;AAAA,QACnD;AAAA,MACF,QAAQ;AAAA,MACR;AACA,YAAM,cAAc,SAAS,eAAe,OAAO,SAAS;AAC5D,YAAM,WAAW,IAAI,IAAI,SAAS,KAAK,OAAO;AAC9C,eAAS,aAAa,IAAI,YAAY,QAAQ;AAC9C,eAAS,aAAa,IAAI,cAAc,KAAK,OAAO,SAAS;AAC7D,eAAS,aAAa,IAAI,SAAS,KAAK;AACxC,eAAS,aAAa,IAAI,QAAQ,OAAO;AACzC,eAAS,aAAa,IAAI,gBAAgB,WAAW;AACrD,YAAM,QAAQ,OAAO;AAAA,QACnB,SAAS,SAAS;AAAA,QAClB;AAAA,QACA;AAAA,MACF;AACA,UAAI,CAAC,OAAO;AACV,eAAO,IAAI,eAAe,kBAAuC,mBAAmB,CAAC;AACrF;AAAA,MACF;AACA,UAAI;AACJ,YAAM,kBAAkB,CAAC,UAAU;AACjC,YAAI,UAAU;AACd,YAAI;AACF,gBAAM,aAAa,IAAI,IAAI,KAAK,OAAO,EAAE;AACzC,cAAI,MAAM,WAAW,WAAY,WAAU;AAAA,QAC7C,QAAQ;AAAA,QACR;AACA,YAAI,MAAM,WAAW,2BAA2B,MAAM,WAAW,wBAAyB,WAAU;AACpG,YAAI,CAAC,QAAS;AACd,YAAI,MAAM,MAAM,SAAS,qBAAqB;AAC5C,gBAAM,EAAE,cAAc,eAAe,YAAY,YAAY,oBAAoB,WAAW,OAAO,cAAc,IAAI,MAAM;AAC3H,cAAI;AACF,kBAAM,WAAW,eAAe,QAAQ,mBAAmB;AAC3D,gBAAI,iBAAiB,YAAY,kBAAkB,UAAU;AAC3D,qBAAO,IAAI,eAAe,uBAAiD,gBAAgB,CAAC;AAC5F,2BAAa,SAAS;AACtB,qBAAO,oBAAoB,WAAW,eAAe;AACrD,oBAAM,MAAM;AACZ;AAAA,YACF;AAAA,UACF,QAAQ;AAAA,UACR;AACA,cAAI,cAAc,KAAK,OAAO,WAAW;AACvC,mBAAO,IAAI,eAAe,uBAAiD,qBAAqB,CAAC;AACjG;AAAA,UACF;AACA,eAAK,UAAU;AAAA,YACb;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,GAAG,IAAI,EAAE,KAAK,MAAM;AAClB,oBAAQ,KAAK,UAAU,IAAI;AAAA,UAC7B,CAAC,EAAE,MAAM,MAAM;AACf,uBAAa,SAAS;AACtB,iBAAO,oBAAoB,WAAW,eAAe;AACrD,gBAAM,MAAM;AAAA,QACd,WAAW,MAAM,MAAM,SAAS,oBAAoB;AAClD,gBAAM,YAAY,KAAK,yBAAyB,MAAM,KAAK,IAAI;AAC/D,iBAAO,IAAI,eAAe,WAAW,MAAM,KAAK,WAAW,uBAAuB,CAAC;AACnF,uBAAa,SAAS;AACtB,iBAAO,oBAAoB,WAAW,eAAe;AACrD,gBAAM,MAAM;AAAA,QACd;AAAA,MACF;AACA,kBAAY,WAAW,MAAM;AAC3B,eAAO,oBAAoB,WAAW,eAAe;AACrD,YAAI,CAAC,MAAM,QAAQ;AACjB,gBAAM,MAAM;AAAA,QACd;AACA,eAAO,IAAI,eAAe,gBAAmC,0BAA0B,CAAC;AAAA,MAC1F,GAAG,GAAG;AACN,YAAM,cAAc,YAAY,MAAM;AACpC,YAAI,MAAM,QAAQ;AAChB,wBAAc,WAAW;AACzB,uBAAa,SAAS;AACtB,iBAAO,oBAAoB,WAAW,eAAe;AACrD,iBAAO,IAAI,eAAe,kBAAuC,6BAA6B,CAAC;AAAA,QACjG;AAAA,MACF,GAAG,GAAG;AACN,aAAO,iBAAiB,WAAW,eAAe;AAAA,IACpD,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,2BAA2B,OAAO;AACtC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,qCAAqC;AAAA,QAC/E,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI;AAAA,UACR;AAAA,UACA,UAAU,SAAS;AAAA,UACnB,UAAU;AAAA,QACZ;AAAA,MACF;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,uBAAuB,OAAO,SAAS;AAC3C,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,4BAA4B;AAAA,QACtE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,WAAW,KAAK,OAAO;AAAA,UACvB,aAAa,SAAS;AAAA,QACxB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,qCAAqC;AAAA,MAC9F;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,qBAAqB,OAAO,aAAa;AAC7C,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,oCAAoC;AAAA,QAC9E,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,UAAU;AAAA,UACV,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,0BAA0B;AAAA,MACnF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,eAAe,aAAa,aAAa;AAC7C,UAAM,QAAQ,MAAM,KAAK,cAAc;AACvC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,eAAe,iBAAqC,2BAA2B;AAAA,IAC3F;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,6BAA6B;AAAA,QACvE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,iBAAiB,UAAU,KAAK;AAAA,UAChC,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,2BAA2B;AAAA,MACpF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,iCAAiC;AACrC,UAAM,QAAQ,MAAM,KAAK,cAAc;AACvC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,eAAe,iBAAqC,2BAA2B;AAAA,IAC3F;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,mCAAmC;AAAA,QAC7E,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,iBAAiB,UAAU,KAAK;AAAA,UAChC,gBAAgB;AAAA,QAClB;AAAA,MACF,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI;AAAA,UACR;AAAA,UACA,UAAU,SAAS;AAAA,UACnB,UAAU;AAAA,QACZ;AAAA,MACF;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,wBAAwB;AAC5B,UAAM,QAAQ,MAAM,KAAK,cAAc;AACvC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,eAAe,iBAAqC,2BAA2B;AAAA,IAC3F;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,+BAA+B;AAAA,QACzE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,iBAAiB,UAAU,KAAK;AAAA,UAChC,gBAAgB;AAAA,QAClB;AAAA,MACF,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,mCAAmC;AAAA,MAC5F;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,YAAY,OAAO;AACvB,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,0BAA0B;AAAA,QACpE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,wBAAwB;AAAA,MACjF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,uBAAuB,OAAO,SAAS;AAC3C,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,mCAAmC;AAAA,QAC7E,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,aAAa,SAAS;AAAA,UACtB,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI;AAAA,UACR;AAAA,UACA,UAAU,SAAS;AAAA,UACnB,UAAU;AAAA,QACZ;AAAA,MACF;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,cAAc,OAAO,SAAS;AAClC,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,0BAA0B;AAAA,QACpE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA,aAAa,SAAS;AAAA,UACtB,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,2BAA2B;AAAA,MACpF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,gBAAgB,OAAO;AAC3B,UAAM,aAAa,SAAS,KAAK,yBAAyB;AAC1D,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,eAAe,uBAAiD,2BAA2B;AAAA,IACvG;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,iCAAiC;AAAA,QAC3E,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,OAAO;AAAA,UACP,WAAW,KAAK,OAAO;AAAA,QACzB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,gCAAgC;AAAA,MACzF;AACA,YAAM,SAAS,MAAM,SAAS,KAAK;AACnC,YAAM,KAAK,UAAU;AAAA,QACnB,cAAc,OAAO;AAAA,QACrB,eAAe,OAAO;AAAA,QACtB,YAAY,OAAO;AAAA,QACnB,YAAY,OAAO;AAAA,QACnB,oBAAoB,OAAO;AAAA,MAC7B,GAAG,IAAI;AACP,aAAO,OAAO;AAAA,IAChB,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,wBAAwB;AAC5B,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,iCAAiC,mBAAmB,KAAK,OAAO,SAAS,CAAC,EAAE;AACxH,UAAI,CAAC,SAAS,IAAI;AAChB,eAAO,CAAC,SAAS,QAAQ;AAAA,MAC3B;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,aAAO,KAAK,aAAa,CAAC,SAAS,QAAQ;AAAA,IAC7C,SAAS,OAAO;AACd,aAAO,CAAC,SAAS,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,MAAM;AACZ,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,CAAC,QAAQ,CAAC,KAAK,MAAM;AACvB,aAAO;AAAA,IACT;AACA,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,aAAO,KAAK,SAAS,KAAK,IAAI;AAAA,IAChC;AACA,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,YAAY,UAAU;AACxB,UAAM,OAAO,KAAK,UAAU;AAC5B,QAAI,CAAC,QAAQ,CAAC,KAAK,MAAM;AACvB,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,KAAK,WAAW;AAC9B,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,IACT;AACA,UAAM,aAAa,MAAM,KAAK,IAAI;AAClC,QAAI,CAAC,YAAY;AACf,aAAO;AAAA,IACT;AACA,QAAI,WAAW,YAAY,SAAS,GAAG,GAAG;AACxC,aAAO;AAAA,IACT;AACA,UAAM,iBAAiB,WAAW,GAAG,UAAU,IAAI,QAAQ,KAAK;AAChE,QAAI,WAAW,YAAY,SAAS,cAAc,GAAG;AACnD,aAAO;AAAA,IACT;AACA,QAAI,WAAW,YAAY,SAAS,UAAU,GAAG;AAC/C,aAAO;AAAA,IACT;AACA,UAAM,UAA0B,oBAAI,IAAI;AACxC,UAAM,sBAAsB,CAAC,aAAa;AACxC,UAAI,QAAQ,IAAI,QAAQ,EAAG,QAAO;AAClC,cAAQ,IAAI,QAAQ;AACpB,YAAM,KAAK,MAAM,QAAQ;AACzB,UAAI,CAAC,GAAI,QAAO;AAChB,UAAI,GAAG,YAAY,SAAS,GAAG,EAAG,QAAO;AACzC,YAAM,kBAAkB,WAAW,GAAG,UAAU,IAAI,QAAQ,KAAK;AACjE,UAAI,GAAG,YAAY,SAAS,eAAe,KAAK,GAAG,YAAY,SAAS,UAAU,EAAG,QAAO;AAC5F,UAAI,GAAG,SAAS;AACd,mBAAW,UAAU,GAAG,SAAS;AAC/B,cAAI,oBAAoB,MAAM,EAAG,QAAO;AAAA,QAC1C;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,QAAI,oBAAoB,KAAK,IAAI,EAAG,QAAO;AAC3C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU;AACd,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB;AACxB,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,mBAAmB;AACvB,YAAQ,IAAI,6BAAoC;AAChD,SAAK,YAAY;AACjB,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAC7B,QAAI,OAAO,WAAW,aAAa;AACjC,WAAK,wBAAwB,KAAK,WAAW;AAC7C,YAAM,KAAK;AAAA,IACb;AACA,YAAQ,IAAI,gCAAqC;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS,SAAS;AACtB,UAAM,QAAQ,KAAK,SAAS;AAC5B,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,eAAe,iBAAqC,2BAA2B;AAAA,IAC3F;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,gBAAgB;AAAA,QAC1D,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,iBAAiB,UAAU,KAAK;AAAA,UAChC,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU,OAAO;AAAA,MAC9B,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,YAAY,MAAM,SAAS,KAAK,EAAE,MAAM,OAAO,CAAC,EAAE;AACxD,cAAM,YAAY,KAAK,yBAAyB,UAAU,IAAI;AAC9D,cAAM,IAAI,eAAe,WAAW,UAAU,SAAS,0BAA0B,SAAS,UAAU,EAAE;AAAA,MACxG;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAM,OAAO,KAAK;AAClB,WAAK,gBAAgB;AAAA,QACnB,GAAG,KAAK;AAAA,QACR;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,gBAAgB;AACnC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,eAAe,iBAAqC,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AAAA,IAC5I;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS,KAAK,UAAU,OAAO;AACnC,UAAM,SAAS;AAAA,MACb,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,YAAY,KAAK;AAAA;AAAA,IAEnB;AACA,UAAM,KAAK,UAAU,QAAQ,OAAO;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,eAAe;AACnB,UAAM,eAAe,KAAK,UAAU,QAAQ;AAC5C,QAAI,CAAC,cAAc;AACjB,aAAO;AAAA,IACT;AACA,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,qBAAqB;AAAA,QAC/D,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACnB,eAAe;AAAA,QACjB,CAAC;AAAA,MACH,CAAC;AACD,UAAI,CAAC,SAAS,IAAI;AAChB,YAAI,SAAS,WAAW,KAAK;AAC3B,eAAK,YAAY;AACjB,cAAI,KAAK,OAAO,cAAc;AAC5B,iBAAK,eAAe;AAAA,UACtB;AAAA,QACF;AACA,eAAO;AAAA,MACT;AACA,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAM,KAAK,UAAU;AAAA,QACnB,cAAc,KAAK;AAAA,QACnB,eAAe,KAAK;AAAA,QACpB,YAAY,KAAK;AAAA,QACjB,YAAY,KAAK;AAAA,QACjB,oBAAoB,KAAK;AAAA,MAC3B,GAAG,IAAI;AACP,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,yBAAyB,KAAK;AAC5C,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB,UAAU;AAC3B,SAAK,UAAU,IAAI,QAAQ;AAC3B,mBAAe,MAAM;AACnB,UAAI;AACF,iBAAS,KAAK,SAAS;AAAA,MACzB,SAAS,OAAO;AACd,gBAAQ,MAAM,wCAAwC,KAAK;AAAA,MAC7D;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,WAAK,UAAU,OAAO,QAAQ;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,qBAAqB,QAAQ;AACjC,QAAI;AACF,cAAQ,IAAI,gCAAuC;AACnD,UAAI,KAAK,qBAAqB,GAAG;AAC/B,gBAAQ,IAAI,kEAAuE;AACnF,YAAI,CAAC,OAAO,eAAe;AACzB,kBAAQ,IAAI,8BAAmC;AAC/C,iBAAO;AAAA,QACT;AACA,YAAI,KAAK,sBAAsB,GAAG;AAChC,kBAAQ,IAAI,8BAAmC;AAC/C,iBAAO;AAAA,QACT;AACA,cAAM,YAAY,MAAM,KAAK,aAAa;AAC1C,YAAI,WAAW;AACb,kBAAQ,IAAI,kDAAuD;AACnE,iBAAO;AAAA,QACT,OAAO;AACL,kBAAQ,IAAI,0CAA+C;AAC3D,iBAAO;AAAA,QACT;AAAA,MACF;AACA,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,gBAAgB;AAAA,QAC1D,SAAS;AAAA,UACP,iBAAiB,UAAU,OAAO,YAAY;AAAA,QAChD;AAAA,MACF,CAAC;AACD,UAAI,SAAS,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,KAAK;AACjC,cAAM,OAAO,KAAK;AAClB,aAAK,gBAAgB;AAAA,UACnB;AAAA,UACA;AAAA,UACA,iBAAiB;AAAA,UACjB,WAAW;AAAA,QACb,CAAC;AACD,gBAAQ,IAAI,+CAAoD;AAChE,eAAO;AAAA,MACT,WAAW,SAAS,WAAW,OAAO,OAAO,eAAe;AAC1D,gBAAQ,IAAI,oEAA2E;AACvF,YAAI,KAAK,sBAAsB,GAAG;AAChC,kBAAQ,IAAI,yBAA8B;AAC1C,iBAAO;AAAA,QACT;AACA,cAAM,YAAY,MAAM,KAAK,aAAa;AAC1C,YAAI,WAAW;AACb,kBAAQ,IAAI,wDAA6D;AACzE,iBAAO;AAAA,QACT,OAAO;AACL,kBAAQ,IAAI,gDAAqD;AACjE,iBAAO;AAAA,QACT;AAAA,MACF,OAAO;AACL,gBAAQ,IAAI,8BAAmC,SAAS,QAAQ,SAAS,UAAU;AACnF,eAAO;AAAA,MACT;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,IAAI,+BAAsC,KAAK;AACvD,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,MAAM,UAAU,QAAQ,SAAS;AAC/B,UAAM,sBAAsB;AAAA,MAC1B,GAAG;AAAA,MACH,WAAW,OAAO,aAAa,KAAK,MAAM,KAAK,IAAI,IAAI,GAAG;AAAA,IAC5D;AACA,YAAQ,IAAI,sBAA6B;AAAA,MACvC;AAAA,MACA,gBAAgB,CAAC,CAAC,oBAAoB;AAAA,MACtC,iBAAiB,CAAC,CAAC,oBAAoB;AAAA,MACvC,WAAW,oBAAoB;AAAA,MAC/B,UAAU,oBAAoB;AAAA,IAChC,CAAC;AACD,QAAI,WAAW,OAAO,WAAW,aAAa;AAC5C,UAAI;AACF,qBAAa,QAAQ,KAAK,cAAc,QAAQ,GAAG,KAAK,UAAU,mBAAmB,CAAC;AACtF,gBAAQ,IAAI,qCAA4C;AAAA,MAC1D,SAAS,OAAO;AACd,gBAAQ,IAAI,+CAAsD,KAAK;AACvE,YAAI,iBAAiB,gBAAgB,MAAM,SAAS,iBAAiB;AACnE,kBAAQ,IAAI,iEAAwE;AAAA,QACtF;AAAA,MACF;AAAA,IACF;AACA,QAAI,OAAO;AACX,QAAI;AACF,cAAQ,IAAI,0BAAiC;AAC7C,YAAM,WAAW,MAAM,MAAM,GAAG,KAAK,OAAO,gBAAgB;AAAA,QAC1D,SAAS;AAAA,UACP,iBAAiB,UAAU,oBAAoB,YAAY;AAAA,QAC7D;AAAA,MACF,CAAC;AACD,cAAQ,IAAI,2BAAkC;AAAA,QAC5C,QAAQ,SAAS;AAAA,QACjB,YAAY,SAAS;AAAA,QACrB,IAAI,SAAS;AAAA,MACf,CAAC;AACD,UAAI,SAAS,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,KAAK;AACjC,eAAO,KAAK;AACZ,gBAAQ,IAAI,qCAA0C;AAAA,UACpD,IAAI,MAAM;AAAA,UACV,OAAO,MAAM;AAAA,UACb,aAAa,MAAM;AAAA,QACrB,CAAC;AAAA,MACH,OAAO;AACL,gBAAQ,IAAI,gCAAqC,MAAM,SAAS,KAAK,CAAC;AAAA,MACxE;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,IAAI,gCAAuC,KAAK;AAAA,IAC1D;AACA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,QAAQ;AAAA,MACR,iBAAiB,CAAC,CAAC;AAAA,MACnB,WAAW;AAAA,IACb,CAAC;AACD,YAAQ,IAAI,0BAAiC;AAAA,MAC3C,SAAS,CAAC,CAAC;AAAA,MACX,iBAAiB,CAAC,CAAC;AAAA,MACnB,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EACA,cAAc;AACZ,QAAI,OAAO,WAAW,aAAa;AACjC,UAAI;AACF,qBAAa,WAAW,KAAK,cAAc,QAAQ,CAAC;AAAA,MACtD,SAAS,OAAO;AACd,gBAAQ,IAAI,+CAAsD,KAAK;AAAA,MACzE;AAAA,IACF;AACA,SAAK,gBAAgB;AAAA,MACnB,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EACA,kBAAkB;AAChB,QAAI,OAAO,WAAW,YAAa,QAAO;AAC1C,QAAI,KAAK,YAAY,KAAK,oBAAoB;AAC5C,aAAO,KAAK;AAAA,IACd;AACA,QAAI;AACF,YAAM,SAAS,aAAa,QAAQ,KAAK,cAAc,QAAQ,CAAC;AAChE,cAAQ,IAAI,wCAA+C;AAAA,QACzD,eAAe,CAAC,CAAC;AAAA,QACjB,cAAc,QAAQ,UAAU;AAAA,QAChC,QAAQ,OAAO,SAAS;AAAA,QACxB,UAAU,OAAO,SAAS,OAAO;AAAA,MACnC,CAAC;AACD,UAAI,QAAQ;AACV,cAAM,SAAS,KAAK,MAAM,MAAM;AAChC,gBAAQ,IAAI,4BAAmC;AAAA,UAC7C,gBAAgB,CAAC,CAAC,OAAO;AAAA,UACzB,iBAAiB,CAAC,CAAC,OAAO;AAAA,UAC1B,WAAW,OAAO;AAAA,UAClB,WAAW,OAAO;AAAA,QACpB,CAAC;AACD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,IAAI,oCAA2C,KAAK;AAC5D,UAAI,iBAAiB,gBAAgB,MAAM,SAAS,iBAAiB;AACnE,gBAAQ,IAAI,iFAAwF;AAAA,MACtG;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,uBAAuB;AACrB,QAAI,OAAO,WAAW,YAAa,QAAO;AAC1C,UAAM,SAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACzD,UAAM,cAAc,OAAO,IAAI,cAAc;AAC7C,UAAM,eAAe,OAAO,IAAI,eAAe;AAC/C,YAAQ,IAAI,kCAAyC;AAAA,MACnD,KAAK,OAAO,SAAS;AAAA,MACrB,aAAa,cAAc,GAAG,YAAY,UAAU,GAAG,EAAE,CAAC,QAAQ;AAAA,MAClE,cAAc,eAAe,GAAG,aAAa,UAAU,GAAG,EAAE,CAAC,QAAQ;AAAA,MACrE,WAAW,OAAO,YAAY,OAAO,QAAQ,CAAC;AAAA,IAChD,CAAC;AACD,QAAI,aAAa;AACf,YAAM,SAAS;AAAA,QACb,cAAc;AAAA,QACd,eAAe,gBAAgB;AAAA,QAC/B,YAAY;AAAA,QACZ,YAAY,KAAK;AAAA;AAAA,QAEjB,oBAAoB,eAAe,KAAK,KAAK,KAAK,KAAK;AAAA;AAAA,QAEvD,WAAW,KAAK,MAAM,KAAK,IAAI,IAAI,GAAG;AAAA;AAAA,MAExC;AACA,cAAQ,IAAI,oCAAyC;AAAA,QACnD,gBAAgB,CAAC,CAAC,OAAO;AAAA,QACzB,iBAAiB,CAAC,CAAC,OAAO;AAAA,MAC5B,CAAC;AACD,aAAO;AAAA,IACT;AACA,YAAQ,IAAI,gCAAqC;AACjD,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AACf,QAAI,OAAO,WAAW,YAAa;AACnC,UAAM,MAAM,IAAI,IAAI,OAAO,SAAS,IAAI;AACxC,QAAI,aAAa,OAAO,cAAc;AACtC,QAAI,aAAa,OAAO,eAAe;AACvC,QAAI,aAAa,OAAO,YAAY;AACpC,QAAI,aAAa,OAAO,YAAY;AACpC,QAAI,aAAa,OAAO,YAAY;AACpC,QAAI,aAAa,OAAO,oBAAoB;AAC5C,QAAI,aAAa,OAAO,OAAO;AAC/B,QAAI,aAAa,OAAO,MAAM;AAC9B,QAAI,aAAa,OAAO,OAAO;AAC/B,QAAI,aAAa,OAAO,mBAAmB;AAC3C,WAAO,QAAQ,aAAa,CAAC,GAAG,IAAI,IAAI,SAAS,CAAC;AAClD,YAAQ,IAAI,4CAAmD;AAAA,EACjE;AAAA,EACA,iBAAiB;AACf,QAAI,OAAO,WAAW,aAAa;AACjC,WAAK,MAAM;AAAA,IACb;AAAA,EACF;AAAA,EACA,WAAW,SAAS;AAClB,SAAK,gBAAgB;AAAA,MACnB,GAAG,KAAK;AAAA,MACR,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EACA,gBAAgB,UAAU;AACxB,SAAK,YAAY;AACjB,SAAK,UAAU,QAAQ,CAAC,aAAa;AACnC,UAAI;AACF,iBAAS,QAAQ;AAAA,MACnB,SAAS,OAAO;AACd,gBAAQ,MAAM,wCAAwC,KAAK;AAAA,MAC7D;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgB;AACd,QAAI,OAAO,WAAW,eAAe,OAAO,iBAAiB;AAC3D,YAAM,QAAQ,IAAI,WAAW,EAAE;AAC/B,aAAO,gBAAgB,KAAK;AAC5B,aAAO,MAAM,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAAA,IAChF,OAAO;AACL,aAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAAA,IACjG;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,2BAA2B;AACzB,QAAI,OAAO,WAAW,YAAa,QAAO;AAC1C,UAAM,SAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACzD,WAAO,OAAO,IAAI,aAAa,KAAK,OAAO,IAAI,OAAO;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAIA,yBAAyB,YAAY;AACnC,YAAQ,YAAY;AAAA,MAClB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,oBAAoB;AAClB,QAAI,OAAO,WAAW,YAAa;AACnC,WAAO,iBAAiB,WAAW,CAAC,MAAM;AACxC,UAAI,EAAE,QAAQ,KAAK,cAAc,QAAQ,GAAG;AAC1C,cAAM,YAAY,EAAE,WAAW,KAAK,MAAM,EAAE,QAAQ,IAAI;AACxD,YAAI,aAAa,cAAc,KAAK,UAAU,QAAQ;AACpD,eAAK,UAAU,WAAW,KAAK,EAAE,MAAM,CAAC,UAAU;AAChD,oBAAQ,MAAM,yCAAyC,KAAK;AAAA,UAC9D,CAAC;AAAA,QACH,WAAW,CAAC,aAAa,KAAK,UAAU,QAAQ;AAC9C,eAAK,YAAY;AAAA,QACnB;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAGA,SAAS,cAAc,KAAK;AAC1B,SAAO,IAAI,QAAQ,UAAU,CAAC,WAAW,IAAI,OAAO,YAAY,CAAC,EAAE;AACrE;AACA,SAAS,mBAAmB;AAC1B,MAAI,OAAO,WAAW,eAAe,OAAO,iBAAiB;AAC3D,UAAM,QAAQ,IAAI,WAAW,EAAE;AAC/B,WAAO,gBAAgB,KAAK;AAC5B,WAAO,MAAM,KAAK,OAAO,CAAC,SAAS,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAAA,EAChF,OAAO;AACL,UAAM,YAAY,KAAK,IAAI,EAAE,SAAS,EAAE;AACxC,UAAM,aAAa,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAC7D,UAAM,cAAc,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAC9D,WAAO,GAAG,SAAS,IAAI,UAAU,IAAI,WAAW;AAAA,EAClD;AACF;AACA,SAAS,eAAe,QAAQ;AAC9B,MAAI,CAAC,OAAO,IAAI;AACd,WAAO,EAAE,GAAG,QAAQ,IAAI,iBAAiB,EAAE;AAAA,EAC7C;AACA,SAAO;AACT;AACA,IAAI,aAAa,MAAM;AAAA,EACrB,YAAY,WAAW,YAAY;AACjC,SAAK,YAAY;AACjB,SAAK,aAAa;AAClB,SAAK,kBAAkB,cAAc,SAAS;AAAA,EAChD;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,MAAM,UAAU,CAAC,GAAG;AAC/B,UAAM,SAAS,eAAe,IAAI;AAClC,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,KAAK;AAAA,MACL;AAAA,MACA,EAAE,WAAW,QAAQ,cAAc,MAAM;AAAA,IAC3C;AACA,UAAM,SAAS,MAAM,QAAQ,SAAS,IAAI,IAAI,SAAS,KAAK,CAAC,IAAI,SAAS;AAC1E,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW,MAAM,UAAU,CAAC,GAAG;AACnC,UAAM,UAAU,KAAK,IAAI,cAAc;AACvC,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,KAAK;AAAA,MACL;AAAA,MACA,EAAE,WAAW,QAAQ,cAAc,MAAM;AAAA,IAC3C;AACA,UAAM,UAAU,MAAM,QAAQ,SAAS,IAAI,IAAI,SAAS,OAAO,CAAC,SAAS,IAAI;AAC7E,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,MAAM,UAAU,CAAC,GAAG;AAC/B,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ,cAAc,OAAO;AAC/B,cAAQ,SAAS;AAAA,IACnB;AACA,QAAI,QAAQ,YAAY;AACtB,cAAQ,QAAQ,IAAI,GAAG,QAAQ,QAAQ,KAAK,EAAE,+BAA+B,KAAK;AAAA,IACpF;AACA,UAAM,SAAS,eAAe,IAAI;AAClC,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,WAAW,KAAK,WAAW,SAAS,YAAY,KAAK,eAAe,gBAAgB,QAAQ,cAAc,IAAI;AAAA,MAC9G;AAAA,QACE,QAAQ;AAAA,QACR,MAAM;AAAA,QACN;AAAA,MACF;AAAA,IACF;AACA,UAAM,SAAS,MAAM,QAAQ,SAAS,IAAI,IAAI,SAAS,KAAK,CAAC,IAAI,SAAS;AAC1E,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW,MAAM,UAAU,CAAC,GAAG;AACnC,UAAM,UAAU,KAAK,IAAI,cAAc;AACvC,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ,cAAc,OAAO;AAC/B,cAAQ,SAAS;AAAA,IACnB;AACA,QAAI,QAAQ,YAAY;AACtB,cAAQ,QAAQ,IAAI,GAAG,QAAQ,QAAQ,KAAK,EAAE,+BAA+B,KAAK;AAAA,IACpF;AACA,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,WAAW,KAAK,WAAW,SAAS,YAAY,KAAK,eAAe,gBAAgB,QAAQ,cAAc,IAAI;AAAA,MAC9G;AAAA,QACE,QAAQ;AAAA,QACR,MAAM;AAAA,QACN;AAAA,MACF;AAAA,IACF;AACA,UAAM,UAAU,MAAM,QAAQ,SAAS,IAAI,IAAI,SAAS,OAAO,CAAC,SAAS,IAAI;AAC7E,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,IAAI,IAAI;AACZ,UAAM,eAAe;AAAA,MACnB,IAAI,MAAM,EAAE;AAAA,MACZ,OAAO;AAAA,IACT;AACA,UAAM,WAAW,MAAM,KAAK,WAAW,MAAM,KAAK,iBAAiB,YAAY;AAC/E,UAAM,UAAU,SAAS;AACzB,QAAI,QAAQ,WAAW,GAAG;AACxB,aAAO;AAAA,IACT;AACA,WAAO,QAAQ,CAAC,KAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,KAAK,UAAU,CAAC,GAAG;AACvB,UAAM,cAAc,WAAW,OAAO;AACtC,UAAM,eAAe;AACrB,UAAM,WAAW,MAAM,KAAK,WAAW,MAAM,KAAK,iBAAiB,YAAY;AAC/E,UAAM,UAAU,SAAS;AACzB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,IAAI,MAAM,UAAU,CAAC,GAAG;AACnC,UAAM,eAAe;AAAA,MACnB,IAAI,MAAM,EAAE;AAAA,IACd;AACA,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,EAAE,WAAW,QAAQ,cAAc,MAAM;AAAA,IAC3C;AACA,UAAM,UAAU,SAAS;AACzB,QAAI,CAAC,WAAW,QAAQ,WAAW,GAAG;AACpC,YAAM,IAAI,MAAM,kBAAkB,EAAE,YAAY;AAAA,IAClD;AACA,WAAO,QAAQ,CAAC;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW,SAAS,UAAU,CAAC,GAAG;AACtC,UAAM,UAAU,CAAC;AACjB,eAAW,UAAU,SAAS;AAC5B,YAAM,EAAE,IAAI,GAAG,KAAK,IAAI;AACxB,YAAM,SAAS,MAAM,KAAK,OAAO,IAAI,MAAM,OAAO;AAClD,cAAQ,KAAK,MAAM;AAAA,IACrB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,IAAI;AACf,UAAM,eAAe;AAAA,MACnB,IAAI,MAAM,EAAE;AAAA,IACd;AACA,UAAM,KAAK,WAAW,SAAS,KAAK,iBAAiB,YAAY;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,WAAW,SAAS;AACxB,UAAM,cAAc,WAAW,EAAE,OAAO,QAAQ,MAAM,CAAC;AACvD,UAAM,eAAe;AACrB,UAAM,KAAK,WAAW,SAAS,KAAK,iBAAiB,YAAY;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,MAAM,UAAU,CAAC,GAAG;AACxB,UAAM,cAAc,WAAW;AAAA,MAC7B,OAAO,QAAQ;AAAA,MACf,QAAQ,CAAC,IAAI;AAAA,IACf,CAAC;AACD,UAAM,WAAW,MAAM,KAAK,WAAW;AAAA,MACrC,WAAW,KAAK,WAAW,SAAS,YAAY,KAAK,eAAe;AAAA,MACpE;AAAA,QACE,QAAQ;AAAA,QACR,cAAc;AAAA,QACd,SAAS;AAAA,UACP,UAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AACA,UAAM,eAAe,SAAS,QAAQ,IAAI,eAAe;AACzD,QAAI,cAAc;AAChB,YAAM,QAAQ,aAAa,MAAM,UAAU;AAC3C,UAAI,SAAS,MAAM,CAAC,GAAG;AACrB,eAAO,SAAS,MAAM,CAAC,GAAG,EAAE;AAAA,MAC9B;AAAA,IACF;AACA,UAAM,UAAU,SAAS;AACzB,WAAO,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,OAAO,SAAS;AACpB,UAAM,QAAQ,MAAM,KAAK,MAAM,OAAO;AACtC,WAAO,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,IAAI,OAAO,QAAQ;AACvB,UAAM,WAAW,MAAM,KAAK,WAAW,MAAM,OAAO,MAAM;AAC1D,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,QAAQ;AACpB,WAAO,OAAO,MAAM,OAAO,OAAO,OAAO,KAAK,OAAO,CAAC;AAAA,EACxD;AACF;AACA,IAAI,gBAAgB,MAAM;AAAA,EACxB,YAAY,YAAY;AACtB,SAAK,aAAa;AAClB,UAAM,QAAQ,IAAI,MAAM,MAAM;AAAA,MAC5B,IAAI,QAAQ,MAAM;AAChB,YAAI,SAAS,SAAS;AACpB,iBAAO,OAAO,MAAM,KAAK,MAAM;AAAA,QACjC;AACA,YAAI,QAAQ,QAAQ;AAClB,gBAAM,QAAQ,OAAO,IAAI;AACzB,iBAAO,OAAO,UAAU,aAAa,MAAM,KAAK,MAAM,IAAI;AAAA,QAC5D;AACA,YAAI,OAAO,SAAS,UAAU;AAC5B,iBAAO,OAAO,MAAM,IAAI;AAAA,QAC1B;AACA,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EACA,SAAyB,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA,EAIjC,MAAM,WAAW;AACf,QAAI,CAAC,KAAK,OAAO,IAAI,SAAS,GAAG;AAC/B,WAAK,OAAO,IAAI,WAAW,IAAI,WAAW,WAAW,KAAK,UAAU,CAAC;AAAA,IACvE;AACA,UAAM,QAAQ,KAAK,OAAO,IAAI,SAAS;AACvC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,SAAS,SAAS,YAAY;AAAA,IAChD;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,IAAI,OAAO,QAAQ;AACvB,UAAM,WAAW,MAAM,KAAK,WAAW,MAAM,OAAO,MAAM;AAC1D,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,MAAM,YAAY,OAAO,SAAS;AACtC,UAAM,WAAW,MAAM,KAAK,WAAW,QAAQ,YAAY,IAAI;AAC/D,WAAO,SAAS;AAAA,EAClB;AACF;AAGA,IAAI,mBAAmB,MAAM;AAAA,EAC3B,YAAY,YAAY;AACtB,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,MAAM,OAAO,MAAM,MAAM,UAAU,CAAC,GAAG;AACrC,QAAI;AACF,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,kBAAkB,kBAAkB;AAAA,MAChD;AACA,UAAI,CAAC,QAAQ,OAAO,SAAS,YAAY,CAAC,KAAK,KAAK,GAAG;AACrD,cAAM,IAAI,kBAAkB,iCAAiC;AAAA,MAC/D;AACA,YAAM,UAAU,KAAK,OAAO;AAC5B,UAAI,WAAW;AACf,UAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAChD,mBAAW,KAAK;AAAA,MAClB,WAAW,OAAO,WAAW,eAAe,gBAAgB,QAAQ;AAClE,mBAAW,KAAK;AAAA,MAClB;AACA,UAAI,WAAW,SAAS;AACtB,cAAM,IAAI,kBAAkB,cAAc,KAAK,MAAM,WAAW,OAAO,IAAI,CAAC,yCAAyC;AAAA,MACvH;AACA,YAAM,EAAE,eAAe,oBAAoB,IAAI,MAAM,KAAK,6BAA6B,MAAM,IAAI;AACjG,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,gBAAgB,KAAK,WAAW,SAAS;AAAA,QACzC;AAAA,QACA;AAAA;AAAA,QAEA;AAAA,UACE,QAAQ,QAAQ;AAAA,UAChB,YAAY,QAAQ;AAAA,UACpB,aAAa;AAAA;AAAA,QAEf;AAAA,MACF;AACA,UAAI,SAAS,MAAM,MAAM,WAAW;AAClC,eAAO,EAAE,WAAW,SAAS,KAAK,KAAK,UAAU;AAAA,MACnD,WAAW,SAAS,MAAM,WAAW;AACnC,eAAO,EAAE,WAAW,SAAS,KAAK,UAAU;AAAA,MAC9C,OAAO;AACL,cAAM,IAAI,kBAAkB,4CAA4C;AAAA,MAC1E;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM;AAAA,MACR;AACA,UAAI,iBAAiB,SAAS,YAAY,OAAO;AAC/C,cAAM,SAAS,MAAM;AACrB,YAAI,WAAW,KAAK;AAClB,gBAAM,IAAI,kBAAkB,uDAAuD,GAAG;AAAA,QACxF;AACA,YAAI,WAAW,KAAK;AAClB,gBAAM,IAAI,kBAAkB,8BAA8B,GAAG;AAAA,QAC/D;AAAA,MACF;AACA,YAAM,IAAI;AAAA,QACR,kBAAkB,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC1E;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,6BAA6B,MAAM,cAAc;AACrD,QAAI;AACF,YAAM,gBAAgB,MAAM,KAAK,iBAAiB,IAAI;AACtD,YAAM,eAAe,KAAK,4BAA4B,aAAa;AACnE,UAAI,sBAAsB,aAAa;AACvC,UAAI,oBAAoB,aAAa;AACrC,UAAI,CAAC,uBAAuB,gBAAgB,QAAQ,KAAK,MAAM;AAC7D,8BAAsB,KAAK;AAC3B,4BAAoB,KAAK,yBAAyB,KAAK,IAAI;AAAA,MAC7D;AACA,UAAI,CAAC,qBAAqB;AACxB,8BAAsB;AACtB,4BAAoB;AAAA,MACtB;AACA,YAAM,YAAY,aAAa,MAAM,GAAG;AACxC,YAAM,WAAW,UAAU,UAAU,SAAS,CAAC;AAC/C,YAAM,YAAY,UAAU,MAAM,GAAG,EAAE,EAAE,KAAK,GAAG;AACjD,UAAI,CAAC,UAAU;AACb,cAAM,IAAI,MAAM,wCAAwC;AAAA,MAC1D;AACA,YAAM,iBAAiB,SAAS,SAAS,GAAG,IAAI,SAAS,UAAU,GAAG,SAAS,YAAY,GAAG,CAAC,IAAI;AACnG,YAAM,oBAAoB,GAAG,cAAc,IAAI,iBAAiB;AAChE,YAAM,gBAAgB,YAAY,GAAG,SAAS,IAAI,iBAAiB,KAAK;AACxE,aAAO;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,KAAK,oDAAoD,KAAK;AACtE,aAAO;AAAA,QACL,eAAe;AAAA,QACf,qBAAqB;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,iBAAiB,MAAM;AAC3B,UAAM,cAAc;AACpB,QAAI,OAAO,WAAW,eAAe,gBAAgB,QAAQ;AAC3D,aAAO,IAAI,WAAW,KAAK,MAAM,GAAG,WAAW,CAAC;AAAA,IAClD;AACA,QAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAChD,YAAM,QAAQ,KAAK,MAAM,GAAG,WAAW;AACvC,YAAM,cAAc,MAAM,MAAM,YAAY;AAC5C,aAAO,IAAI,WAAW,WAAW;AAAA,IACnC;AACA,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,4BAA4B,WAAW;AACrC,UAAM,MAAM,MAAM,KAAK,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AACrF,UAAM,aAAa;AAAA;AAAA,MAEjB,UAAU,EAAE,UAAU,cAAc,WAAW,MAAM;AAAA,MACrD,YAAY,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA,MACtD,YAAY,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA,MACtD,YAAY,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA;AAAA,MAExD,QAAQ,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA,MAClD,YAAY,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA,MACxD,YAAY,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA;AAAA,MAExD,YAAY,EAAE,UAAU,mBAAmB,WAAW,MAAM;AAAA,MAC5D,YAAY,EAAE,UAAU,mBAAmB,WAAW,MAAM;AAAA;AAAA,MAE5D,YAAY,EAAE,UAAU,sBAAsB,WAAW,MAAM;AAAA;AAAA,MAE/D,UAAU,EAAE,UAAU,cAAc,WAAW,MAAM;AAAA,MACrD,YAAY,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA,MACxD,YAAY,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA;AAAA,MAEtD,UAAU,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA;AAAA,MAEpD,YAAY,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA;AAAA,MAExD,UAAU,EAAE,UAAU,cAAc,WAAW,MAAM;AAAA;AAAA,IAEvD;AACA,eAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,UAAU,GAAG;AACpD,UAAI,IAAI,WAAW,GAAG,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,IAAI,WAAW,UAAU,KAAK,IAAI,UAAU,IAAI,EAAE,MAAM,YAAY;AACtE,aAAO,EAAE,UAAU,cAAc,WAAW,OAAO;AAAA,IACrD;AACA,QAAI,IAAI,UAAU,GAAG,EAAE,MAAM,YAAY;AACvC,aAAO,EAAE,UAAU,aAAa,WAAW,MAAM;AAAA,IACnD;AACA,WAAO,EAAE,UAAU,IAAI,WAAW,GAAG;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAIA,yBAAyB,UAAU;AACjC,UAAM,YAAY;AAAA,MAChB,cAAc;AAAA,MACd,aAAa;AAAA,MACb,aAAa;AAAA,MACb,cAAc;AAAA,MACd,aAAa;AAAA,MACb,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,MACnB,cAAc;AAAA,MACd,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,0BAA0B;AAAA,MAC1B,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,aAAa;AAAA,MACb,aAAa;AAAA,MACb,aAAa;AAAA,MACb,cAAc;AAAA,MACd,mBAAmB;AAAA,IACrB;AACA,WAAO,UAAU,QAAQ,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,MAAM,SAAS,MAAM,UAAU,CAAC,GAAG;AACjC,QAAI;AACF,UAAI,CAAC,QAAQ,OAAO,SAAS,YAAY,CAAC,KAAK,KAAK,GAAG;AACrD,cAAM,IAAI,kBAAkB,iCAAiC;AAAA,MAC/D;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,gBAAgB,KAAK,WAAW,SAAS;AAAA,QACzC;AAAA,UACE,QAAQ;AAAA,UACR,cAAc;AAAA,YACZ,MAAM,KAAK,KAAK;AAAA,YAChB,GAAG,QAAQ,YAAY,EAAE,UAAU,QAAQ,SAAS;AAAA,UACtD;AAAA,QACF;AAAA,MACF;AACA,UAAI,SAAS,MAAM,aAAa;AAC9B,eAAO;AAAA,UACL,aAAa,SAAS,KAAK;AAAA,UAC3B,UAAU,SAAS,KAAK,YAAY,QAAQ,YAAY,KAAK,MAAM,GAAG,EAAE,IAAI,KAAK;AAAA,UACjF,aAAa,SAAS,KAAK;AAAA,UAC3B,MAAM,SAAS,KAAK;AAAA,QACtB;AAAA,MACF,OAAO;AACL,cAAM,IAAI,kBAAkB,8CAA8C;AAAA,MAC5E;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM;AAAA,MACR;AACA,UAAI,iBAAiB,SAAS,YAAY,OAAO;AAC/C,cAAM,SAAS,MAAM;AACrB,YAAI,WAAW,KAAK;AAClB,gBAAM,IAAI,kBAAkB,kBAAkB,GAAG;AAAA,QACnD;AACA,YAAI,WAAW,KAAK;AAClB,gBAAM,IAAI,kBAAkB,8BAA8B,GAAG;AAAA,QAC/D;AAAA,MACF;AACA,YAAM,IAAI;AAAA,QACR,oBAAoB,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC5E;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,UAAU,OAAO;AACrB,QAAI;AACF,UAAI,MAAM,WAAW,GAAG;AACtB,cAAM,IAAI,kBAAkB,oCAAoC;AAAA,MAClE;AACA,iBAAW,QAAQ,OAAO;AACxB,YAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,gBAAM,IAAI,kBAAkB,qCAAqC;AAAA,QACnE;AAAA,MACF;AACA,YAAM,KAAK,WAAW;AAAA,QACpB,gBAAgB,KAAK,WAAW,SAAS;AAAA,QACzC;AAAA,UACE,QAAQ;AAAA,UACR,MAAM,EAAE,MAAM;AAAA,UACd,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM;AAAA,MACR;AACA,UAAI,iBAAiB,SAAS,YAAY,OAAO;AAC/C,cAAM,SAAS,MAAM;AACrB,YAAI,WAAW,KAAK;AAClB,gBAAM,IAAI,kBAAkB,8BAA8B,GAAG;AAAA,QAC/D;AAAA,MACF;AACA,YAAM,IAAI;AAAA,QACR,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACnF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACF;AAGA,IAAI,cAAc,MAAM;AAAA,EACtB,YAAY,YAAY;AACtB,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA,EAEA,0BAA0B,CAAC,OAAO,QAAQ,OAAO,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA,EAI9D,iBAAiB,KAAK;AACpB,QAAI;AACF,YAAM,YAAY,IAAI,IAAI,GAAG;AAC7B,UAAI,UAAU,aAAa,UAAU;AACnC,eAAO,EAAE,SAAS,OAAO,OAAO,qCAAqC;AAAA,MACvE;AACA,YAAM,WAAW,UAAU,SAAS,YAAY;AAChD,YAAM,oBAAoB,KAAK,wBAAwB;AAAA,QACrD,CAAC,WAAW,SAAS,SAAS,IAAI,MAAM,EAAE;AAAA,MAC5C;AACA,UAAI,CAAC,mBAAmB;AACtB,eAAO;AAAA,UACL,SAAS;AAAA,UACT,OAAO,+CAA+C,KAAK,wBAAwB,KAAK,IAAI,CAAC;AAAA,QAC/F;AAAA,MACF;AACA,aAAO,EAAE,SAAS,KAAK;AAAA,IACzB,SAAS,OAAO;AACd,aAAO,EAAE,SAAS,OAAO,OAAO,qBAAqB;AAAA,IACvD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB,UAAU;AACzB,UAAM,SAAS,CAAC;AAChB,aAAS,QAAQ,CAAC,SAAS,iBAAiB;AAC1C,UAAI,MAAM,QAAQ,QAAQ,OAAO,GAAG;AAClC,gBAAQ,QAAQ,QAAQ,CAAC,MAAM,iBAAiB;AAC9C,cAAI,KAAK,SAAS,SAAS;AACzB,gBAAI,CAAC,KAAK,SAAS,OAAO,KAAK,UAAU,UAAU;AACjD,qBAAO,KAAK,WAAW,YAAY,aAAa,YAAY,6CAA6C;AAAA,YAC3G,OAAO;AACL,oBAAM,aAAa,KAAK,iBAAiB,KAAK,KAAK;AACnD,kBAAI,CAAC,WAAW,SAAS;AACvB,uBAAO,KAAK,WAAW,YAAY,aAAa,YAAY,KAAK,WAAW,KAAK,EAAE;AAAA,cACrF;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,WAAO,EAAE,SAAS,OAAO,WAAW,GAAG,OAAO;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqB,QAAQ;AAC3B,UAAM,YAAY;AAAA,MAChB,KAAK;AAAA,MACL,MAAM;AAAA,MACN,KAAK;AAAA,MACL,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,WAAO,UAAU,MAAM,KAAK;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiFA,MAAM,aAAa,SAAS;AAC1B,QAAI;AACF,UAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,UAAU;AACxC,cAAM,IAAI,aAAa,uCAAuC;AAAA,MAChE;AACA,UAAI,QAAQ,UAAU;AACpB,cAAM,aAAa,KAAK,iBAAiB,QAAQ,QAAQ;AACzD,YAAI,CAAC,WAAW,SAAS;AACvB,gBAAM,IAAI,aAAa,8BAA8B,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,QACrF;AAAA,MACF;AACA,YAAM,cAAc;AAAA,QAClB,OAAO,QAAQ;AAAA,QACf,QAAQ;AAAA,QACR,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA,QAClB,4BAA4B,QAAQ;AAAA,QACpC,WAAW,QAAQ;AAAA,QACnB,aAAa,QAAQ;AAAA,QACrB,QAAQ,QAAQ;AAAA,MAClB;AACA,UAAI,QAAQ,QAAQ;AAClB,oBAAY,SAAS,QAAQ;AAAA,MAC/B;AACA,UAAI,QAAQ,UAAU;AACpB,oBAAY,WAAW,QAAQ;AAAA,MACjC;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ,UAAU;AAAA,QAClB;AAAA,MACF;AACA,UAAI,SAAS,MAAM,QAAQ;AACzB,eAAO,SAAS,KAAK;AAAA,MACvB,WAAW,SAAS,MAAM,MAAM;AAC9B,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,aAAa,uCAAuC;AAAA,MAChE;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACnF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,MAAM,WAAW,SAAS,SAAS;AACjC,QAAI;AACF,UAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,UAAU;AACxC,cAAM,IAAI,aAAa,uCAAuC;AAAA,MAChE;AACA,UAAI,QAAQ,UAAU;AACpB,cAAM,aAAa,KAAK,iBAAiB,QAAQ,QAAQ;AACzD,YAAI,CAAC,WAAW,SAAS;AACvB,gBAAM,IAAI,aAAa,8BAA8B,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,QACrF;AAAA,MACF;AACA,YAAM,SAAS,MAAM,KAAK,WAAW;AAAA,QACnC,QAAQ,UAAU;AAAA,QAClB;AAAA,UACE,OAAO,QAAQ;AAAA,UACf,UAAU,QAAQ;AAAA,UAClB,QAAQ,QAAQ;AAAA,UAChB,UAAU,QAAQ;AAAA,UAClB,4BAA4B,QAAQ;AAAA,UACpC,WAAW,QAAQ;AAAA,UACnB,aAAa,QAAQ;AAAA,UACrB,QAAQ,QAAQ;AAAA,QAClB;AAAA,QACA;AAAA,MACF;AACA,aAAO;AAAA,QACL,MAAM,OAAO,QAAQ;AAAA,QACrB,cAAc;AAAA,QACd,OAAO,OAAO;AAAA,QACd,GAAG;AAAA,MACL;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAClF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmDA,MAAM,eAAe,SAAS;AAC5B,QAAI;AACF,UAAI,CAAC,QAAQ,QAAQ;AACnB,cAAM,IAAI,aAAa,oBAAoB;AAAA,MAC7C;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ;AAAA,QACR;AAAA,UACE,OAAO,QAAQ;AAAA,UACf,QAAQ,QAAQ;AAAA,UAChB,QAAQ,QAAQ;AAAA,UAChB,MAAM,QAAQ;AAAA,UACd,QAAQ;AAAA,UACR,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF;AACA,UAAI,SAAS,MAAM,QAAQ;AACzB,eAAO,SAAS,KAAK;AAAA,MACvB,WAAW,SAAS,MAAM,QAAQ;AAChC,eAAO,SAAS;AAAA,MAClB,OAAO;AACL,cAAM,IAAI,aAAa,yCAAyC;AAAA,MAClE;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACrF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgCA,MAAM,aAAa,SAAS,WAAW;AACrC,QAAI;AACF,UAAI,CAAC,QAAQ,QAAQ;AACnB,cAAM,IAAI,aAAa,oBAAoB;AAAA,MAC7C;AACA,YAAM,SAAS,MAAM,KAAK,WAAW;AAAA,QACnC,QAAQ;AAAA,QACR;AAAA,UACE,OAAO,QAAQ;AAAA,UACf,QAAQ,QAAQ;AAAA,UAChB,QAAQ,QAAQ;AAAA,UAChB,MAAM,QAAQ;AAAA,UACd,QAAQ,QAAQ;AAAA,QAClB;AAAA,QACA;AAAA,MACF;AACA,aAAO;AAAA,QACL,QAAQ,OAAO,UAAU,CAAC;AAAA,QAC1B,cAAc;AAAA,QACd,OAAO,OAAO;AAAA,QACd,GAAG;AAAA,MACL;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,4BAA4B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACpF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCA,MAAM,cAAc,SAAS;AAC3B,QAAI;AACF,UAAI,CAAC,QAAQ,QAAQ;AACnB,cAAM,IAAI,aAAa,oBAAoB;AAAA,MAC7C;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ;AAAA,QACR;AAAA,UACE,GAAG,QAAQ;AAAA,UACX,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF;AACA,UAAI;AACJ,UAAI,SAAS,MAAM,QAAQ,MAAM;AAC/B,wBAAgB,SAAS,KAAK;AAAA,MAChC,WAAW,SAAS,MAAM,MAAM;AAC9B,wBAAgB,SAAS;AAAA,MAC3B,OAAO;AACL,cAAM,IAAI,aAAa,6CAA6C;AAAA,MACtE;AACA,UAAI,CAAC,MAAM,QAAQ,cAAc,IAAI,GAAG;AACtC,cAAM,IAAI,aAAa,kDAAkD;AAAA,MAC3E;AACA,oBAAc,OAAO,cAAc,KAAK,IAAI,CAAC,SAAS;AACpD,YAAI,OAAO,SAAS,UAAU;AAC5B,iBAAO,EAAE,KAAK,KAAK;AAAA,QACrB,WAAW,KAAK,KAAK;AACnB,iBAAO;AAAA,QACT,OAAO;AACL,gBAAM,IAAI,aAAa,+BAA+B;AAAA,QACxD;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,4BAA4B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACpF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkEA,MAAM,YAAY,SAAS;AACzB,QAAI;AACF,UAAI,CAAC,QAAQ,QAAQ;AACnB,cAAM,IAAI,aAAa,oBAAoB;AAAA,MAC7C;AACA,UAAI,CAAC,QAAQ,UAAU,CAAC,MAAM,QAAQ,QAAQ,MAAM,KAAK,QAAQ,OAAO,WAAW,GAAG;AACpF,cAAM,IAAI,aAAa,kEAAkE;AAAA,MAC3F;AACA,UAAI,QAAQ,OAAO,SAAS,IAAI;AAC9B,cAAM,IAAI,aAAa,2BAA2B;AAAA,MACpD;AACA,eAAS,IAAI,GAAG,IAAI,QAAQ,OAAO,QAAQ,KAAK;AAC9C,cAAM,aAAa,KAAK,iBAAiB,QAAQ,OAAO,CAAC,CAAC;AAC1D,YAAI,CAAC,WAAW,SAAS;AACvB,gBAAM,IAAI,aAAa,SAAS,IAAI,CAAC,KAAK,WAAW,KAAK,EAAE;AAAA,QAC9D;AAAA,MACF;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ;AAAA;AAAA,QAER;AAAA,UACE,QAAQ,QAAQ;AAAA,UAChB,GAAG,QAAQ;AAAA,UACX,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF;AACA,UAAI;AACJ,UAAI,SAAS,MAAM,QAAQ,MAAM;AAC/B,wBAAgB,SAAS,KAAK;AAAA,MAChC,WAAW,SAAS,MAAM,MAAM;AAC9B,wBAAgB,SAAS;AAAA,MAC3B,OAAO;AACL,cAAM,IAAI,aAAa,6CAA6C;AAAA,MACtE;AACA,UAAI,CAAC,MAAM,QAAQ,cAAc,IAAI,GAAG;AACtC,cAAM,IAAI,aAAa,kDAAkD;AAAA,MAC3E;AACA,oBAAc,OAAO,cAAc,KAAK,IAAI,CAAC,SAAS;AACpD,YAAI,OAAO,SAAS,UAAU;AAC5B,iBAAO,EAAE,KAAK,KAAK;AAAA,QACrB,WAAW,KAAK,KAAK;AACnB,iBAAO;AAAA,QACT,OAAO;AACL,gBAAM,IAAI,aAAa,+BAA+B;AAAA,QACxD;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,8BAA8B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACtF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0CA,MAAM,eAAe,SAAS;AAC5B,QAAI;AACF,UAAI,CAAC,QAAQ,MAAM;AACjB,cAAM,IAAI,aAAa,kBAAkB;AAAA,MAC3C;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ;AAAA,QACR;AAAA,UACE,OAAO,QAAQ;AAAA,UACf,OAAO,QAAQ;AAAA,UACf,iBAAiB,QAAQ;AAAA,UACzB,OAAO,QAAQ;AAAA,UACf,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF;AACA,UAAI;AACJ,UAAI,SAAS,MAAM,QAAQ;AACzB,yBAAiB,SAAS,KAAK;AAAA,MACjC,WAAW,SAAS,MAAM,KAAK;AAC7B,yBAAiB,SAAS;AAAA,MAC5B,OAAO;AACL,cAAM,IAAI,aAAa,8CAA8C;AAAA,MACvE;AACA,UAAI,CAAC,eAAe,KAAK;AACvB,YAAI,OAAO,SAAS,SAAS,UAAU;AACrC,2BAAiB;AAAA,YACf,KAAK,SAAS;AAAA,YACd,OAAO,QAAQ,SAAS;AAAA,YACxB,QAAQ,QAAQ,mBAAmB;AAAA,YACnC,UAAU,KAAK,qBAAqB,QAAQ,mBAAmB,KAAK;AAAA,UACtE;AAAA,QACF,WAAW,SAAS,MAAM,MAAM;AAC9B,2BAAiB;AAAA,YACf,KAAK,SAAS,KAAK;AAAA,YACnB,OAAO,QAAQ,SAAS;AAAA,YACxB,QAAQ,QAAQ,mBAAmB;AAAA,YACnC,UAAU,KAAK,qBAAqB,QAAQ,mBAAmB,KAAK;AAAA,UACtE;AAAA,QACF,OAAO;AACL,gBAAM,IAAI,aAAa,6CAA6C;AAAA,QACtE;AAAA,MACF;AACA,UAAI,CAAC,eAAe,OAAO;AACzB,uBAAe,QAAQ,QAAQ,SAAS;AAAA,MAC1C;AACA,UAAI,CAAC,eAAe,QAAQ;AAC1B,uBAAe,SAAS,QAAQ,mBAAmB;AAAA,MACrD;AACA,UAAI,CAAC,eAAe,UAAU;AAC5B,uBAAe,WAAW,KAAK,qBAAqB,eAAe,MAAM;AAAA,MAC3E;AACA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACrF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiDA,MAAM,gBAAgB,SAAS;AAC7B,QAAI;AACF,UAAI,CAAC,QAAQ,OAAO;AAClB,cAAM,IAAI,aAAa,mBAAmB;AAAA,MAC5C;AACA,YAAM,WAAW,MAAM,KAAK,WAAW;AAAA,QACrC,QAAQ;AAAA,QACR;AAAA,UACE,OAAO,QAAQ;AAAA,UACf,UAAU,QAAQ;AAAA,UAClB,iBAAiB,QAAQ;AAAA,UACzB,QAAQ,QAAQ;AAAA,QAClB;AAAA,MACF;AACA,UAAI,SAAS,MAAM,QAAQ;AACzB,eAAO,SAAS,KAAK;AAAA,MACvB,WAAW,SAAS,MAAM,QAAQ,SAAS,MAAM,YAAY;AAC3D,eAAO;AAAA,UACL,MAAM,SAAS,KAAK,QAAQ,SAAS,KAAK;AAAA,UAC1C,YAAY,SAAS,KAAK,cAAc,SAAS,KAAK;AAAA,UACtD,GAAG,SAAS;AAAA,QACd;AAAA,MACF,OAAO;AACL,cAAM,IAAI,aAAa,qDAAqD;AAAA,MAC9E;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AACA,YAAM,IAAI;AAAA,QACR,+BAA+B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QACvF;AAAA,QACA,EAAE,eAAe,MAAM;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACF;AAGA,IAAI,gBAAgB,MAAM;AAAA,EACxB,YAAY,YAAY,WAAW;AACjC,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA,EACnB;AAAA,EACA,MAAM,eAAe,KAAK,UAAU,CAAC,GAAG;AACtC,UAAM,EAAE,WAAW,OAAO,UAAU,IAAI;AACxC,UAAM,UAAU,EAAE,KAAK,UAAU,UAAU;AAC3C,UAAM,WAAW,MAAM,KAAK,WAAW,mBAAmB,KAAK,WAAW,OAAO;AACjF,WAAO,WAAW,SAAS,KAAK,SAAS,SAAS,KAAK;AAAA,EACzD;AAAA,EACA,MAAM,gBAAgB,MAAM,UAAU,CAAC,GAAG;AACxC,UAAM,EAAE,WAAW,OAAO,UAAU,IAAI;AACxC,UAAM,WAAW,MAAM,KAAK,WAAW,oBAAoB,KAAK,WAAW,MAAM,UAAU,SAAS;AACpG,WAAO,WAAW,SAAS,KAAK,SAAS,SAAS,KAAK;AAAA,EACzD;AAAA,EACA,MAAM,OAAO,KAAK;AAChB,UAAM,UAAU;AAAA,MACd;AAAA,MACA,SAAS,CAAC,YAAY,QAAQ,SAAS,WAAW,UAAU;AAAA,IAC9D;AACA,UAAM,WAAW,MAAM,KAAK,WAAW,WAAW,KAAK,WAAW,OAAO;AACzE,UAAM,OAAO,SAAS;AACtB,WAAO;AAAA,MACL,UAAU,KAAK,YAAY;AAAA,MAC3B,MAAM,KAAK,QAAQ;AAAA,MACnB,UAAU;AAAA,QACR,OAAO,KAAK,UAAU,SAAS;AAAA,QAC/B,aAAa,KAAK,UAAU,eAAe;AAAA,QAC3C,KAAK,KAAK,UAAU,OAAO;AAAA,QAC3B,QAAQ,KAAK,UAAU,UAAU,IAAI,IAAI,GAAG,EAAE;AAAA,QAC9C,SAAS,KAAK,UAAU;AAAA,QACxB,OAAO,KAAK,UAAU;AAAA,QACtB,QAAQ,KAAK,UAAU;AAAA,QACvB,eAAe,KAAK,UAAU;AAAA,QAC9B,cAAc,KAAK,UAAU;AAAA,QAC7B,MAAM,KAAK,UAAU;AAAA,QACrB,UAAU,KAAK,UAAU;AAAA,QACzB,QAAQ,KAAK,UAAU;AAAA,QACvB,UAAU,KAAK,UAAU,YAAY,CAAC;AAAA,MACxC;AAAA,MACA,OAAO,KAAK,SAAS,CAAC;AAAA,MACtB,SAAS;AAAA,QACP,OAAO,KAAK,SAAS,SAAS,KAAK,UAAU,SAAS;AAAA,QACtD,aAAa,KAAK,SAAS,eAAe,KAAK,UAAU,eAAe;AAAA,QACxE,UAAU,KAAK,SAAS,YAAY,CAAC;AAAA,QACrC,MAAM,KAAK,SAAS,QAAQ,KAAK,YAAY;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,WAAW,KAAK,UAAU,CAAC,GAAG;AAClC,UAAM,UAAU,EAAE,KAAK,GAAG,QAAQ;AAClC,UAAM,WAAW,MAAM,KAAK,WAAW,eAAe,KAAK,WAAW,OAAO;AAC7E,WAAO,SAAS,KAAK;AAAA,EACvB;AAAA,EACA,MAAM,MAAM,SAAS;AACnB,UAAM,WAAW,MAAM,KAAK,WAAW,UAAU,KAAK,WAAW,OAAO;AACxE,QAAI,YAAY,SAAS,QAAQ,aAAa,SAAS,MAAM;AAC3D,aAAO,SAAS;AAAA,IAClB;AACA,UAAM,IAAI,eAAe,gDAAgD;AAAA,EAC3E;AAAA,EACA,MAAM,WAAW,SAAS;AACxB,UAAM,eAAe,EAAE,GAAG,SAAS,OAAO,KAAK;AAC/C,UAAM,WAAW,MAAM,KAAK,WAAW,UAAU,KAAK,WAAW,YAAY;AAC7E,QAAI,YAAY,SAAS,QAAQ,SAAS,KAAK,WAAW,aAAa;AACrE,aAAO,SAAS;AAAA,IAClB;AACA,UAAM,IAAI,eAAe,sDAAsD;AAAA,EACjF;AAAA,EACA,MAAM,OAAO,OAAO,SAAS;AAC3B,UAAM,gBAAgB,CAAC,SAAS;AAC9B,cAAQ,MAAM;AAAA,QACZ,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AACH,iBAAO;AAAA,QACT,KAAK;AAAA,QACL,KAAK;AACH,iBAAO;AAAA,QACT;AACE,iBAAO;AAAA,MACX;AAAA,IACF;AACA,UAAM,UAAU;AAAA,MACd,GAAG;AAAA,MACH,UAAU,SAAS;AAAA,MACnB,IAAI,SAAS,YAAY;AAAA,MACzB,KAAK,cAAc,SAAS,IAAI;AAAA,MAChC,KAAK,SAAS;AAAA,IAChB;AACA,UAAM,WAAW,MAAM,KAAK,WAAW,WAAW,KAAK,WAAW,OAAO;AACzE,WAAO,SAAS;AAAA,EAClB;AACF;AAGA,IAAI,oBAAoB,MAAM;AAC5B,MAAI,OAAO,cAAc,aAAa;AACpC,WAAO;AAAA,EACT;AACA,MAAI;AACF,UAAM,KAAKA,WAAU,IAAI;AACzB,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,IAAI,mBAAmB,4EAA4E;AAAA,EAC3G;AACF;AACA,IAAI,uBAAuB,MAAM;AAAA,EAC/B,YAAY,aAAa,YAAY,WAAW;AAC9C,SAAK,cAAc;AACnB,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA,EACnB;AAAA,EACA,mBAAmB,CAAC;AAAA,EACpB,oBAAoB,CAAC;AAAA,EACrB,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,cAAc;AAAA,EACd,eAAe;AAAA,EACf,iBAAiB;AAAA,EACjB,iBAAiB;AAAA,EACjB,oBAAoB;AAAA;AAAA,EAEpB,eAAe,CAAC;AAAA,EAChB,sBAAsB;AAAA;AAAA,EAEtB,oBAAoB;AAAA;AAAA;AAAA;AAAA,EAIpB,UAAU;AACR,WAAO,KAAK,eAAe,KAAK;AAAA,EAClC;AAAA,EACA,MAAM,UAAU,UAAU,CAAC,GAAG;AAC5B,QAAI,KAAK,cAAc;AACrB;AAAA,IACF;AACA,UAAM,KAAK,gBAAgB;AAC3B,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,KAAK,qBAAqB;AAC5B,qBAAa,KAAK,oBAAoB,OAAO;AAC7C,aAAK,oBAAoB,OAAO,IAAI,mBAAmB,oDAAoD,CAAC;AAAA,MAC9G;AACA,YAAM,UAAU,WAAW,MAAM;AAC/B,aAAK,sBAAsB;AAC3B,eAAO,IAAI,mBAAmB,sDAAsD,CAAC;AAAA,MACvF,GAAG,GAAG;AACN,WAAK,sBAAsB;AAAA,QACzB;AAAA,QACA,SAAS,MAAM;AACb,uBAAa,OAAO;AACpB,eAAK,sBAAsB;AAC3B,eAAK,eAAe;AACpB,eAAK,eAAe;AACpB,kBAAQ;AAAA,QACV;AAAA,QACA,QAAQ,CAAC,UAAU;AACjB,uBAAa,OAAO;AACpB,eAAK,sBAAsB;AAC3B,iBAAO,KAAK;AAAA,QACd;AAAA,QACA;AAAA,MACF;AACA,YAAM,mBAAmB;AAAA,QACvB,MAAM;AAAA,QACN,SAAS;AAAA,UACP,SAAS,KAAK;AAAA,UACd,QAAQ,QAAQ;AAAA,UAChB,UAAU,QAAQ;AAAA,QACpB;AAAA,MACF;AACA,WAAK,YAAY,KAAK,UAAU,gBAAgB,CAAC,EAAE,MAAM,CAAC,UAAU;AAClE,YAAI,KAAK,qBAAqB;AAC5B,eAAK,oBAAoB,OAAO,KAAK;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EACA,MAAM,cAAc;AAClB,QAAI,CAAC,KAAK,cAAc;AACtB;AAAA,IACF;AACA,QAAI,KAAK,qBAAqB;AAC5B,mBAAa,KAAK,oBAAoB,OAAO;AAC7C,WAAK,oBAAoB,OAAO,IAAI,mBAAmB,uCAAuC,CAAC;AAC/F,WAAK,sBAAsB;AAAA,IAC7B;AACA,QAAI,KAAK,aAAa,KAAK,UAAU,eAAe,GAAG;AACrD,YAAM,qBAAqB;AAAA,QACzB,MAAM;AAAA,QACN,SAAS;AAAA,UACP,SAAS,KAAK;AAAA,QAChB;AAAA,MACF;AACA,WAAK,UAAU,KAAK,KAAK,UAAU,kBAAkB,CAAC;AAAA,IACxD;AACA,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,MAAM,QAAQ,MAAM,MAAM,UAAU,CAAC,GAAG;AACtC,UAAM,KAAK,gBAAgB;AAC3B,UAAM,iBAAiB;AAAA,MACrB,MAAM;AAAA,MACN,SAAS;AAAA,QACP,SAAS,KAAK;AAAA,QACd;AAAA,QACA;AAAA,QACA,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA,MACpB;AAAA,IACF;AACA,WAAO,KAAK,YAAY,KAAK,UAAU,cAAc,CAAC;AAAA,EACxD;AAAA,EACA,UAAU,UAAU;AAClB,SAAK,iBAAiB,KAAK,QAAQ;AACnC,WAAO,MAAM;AACX,YAAM,QAAQ,KAAK,iBAAiB,QAAQ,QAAQ;AACpD,UAAI,QAAQ,IAAI;AACd,aAAK,iBAAiB,OAAO,OAAO,CAAC;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AAAA,EACA,WAAW,UAAU;AACnB,SAAK,kBAAkB,KAAK,QAAQ;AACpC,WAAO,MAAM;AACX,YAAM,QAAQ,KAAK,kBAAkB,QAAQ,QAAQ;AACrD,UAAI,QAAQ,IAAI;AACd,aAAK,kBAAkB,OAAO,OAAO,CAAC;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,cAAc;AAClB,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,WAAW,oBAAoB,KAAK,WAAW,KAAK,WAAW;AAC3F,aAAO,SAAS,KAAK,SAAS,CAAC;AAAA,IACjC,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,sCAAsC,KAAK,WAAW,KAAK,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACrH;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,YAAY,UAAU,CAAC,GAAG;AAC9B,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,WAAW,oBAAoB,KAAK,WAAW;AAAA,QACzE,SAAS,KAAK;AAAA,QACd,OAAO,QAAQ;AAAA,QACf,OAAO,QAAQ,SAAS;AAAA;AAAA,QAExB,KAAK,QAAQ,UAAU;AAAA;AAAA,MAEzB,CAAC;AACD,aAAO,SAAS,KAAK,YAAY,CAAC;AAAA,IACpC,SAAS,OAAO;AACd,YAAM,IAAI;AAAA,QACR,sCAAsC,KAAK,WAAW,KAAK,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACrH;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,kBAAkB;AACtB,QAAI,KAAK,eAAe,KAAK,WAAW,eAAe,GAAG;AACxD;AAAA,IACF;AACA,QAAI,KAAK,mBAAmB;AAC1B,aAAO,KAAK;AAAA,IACd;AACA,SAAK,oBAAoB,KAAK,iBAAiB;AAC/C,QAAI;AACF,YAAM,KAAK;AAAA,IACb,UAAE;AACA,WAAK,oBAAoB;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,SAAS;AACnB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI;AACJ,UAAI;AACF,qBAAa,KAAK,MAAM,OAAO;AAAA,MACjC,SAAS,OAAO;AACd,eAAO,IAAI,mBAAmB,wBAAwB,CAAC;AACvD;AAAA,MACF;AACA,YAAM,UAAU,WAAW,MAAM;AAC/B,cAAM,QAAQ,KAAK,aAAa,UAAU,CAAC,MAAM,EAAE,YAAY,OAAO;AACtE,YAAI,QAAQ,IAAI;AACd,eAAK,aAAa,OAAO,OAAO,CAAC;AAAA,QACnC;AACA,eAAO,IAAI,mBAAmB,gDAAgD,CAAC;AAAA,MACjF,GAAG,GAAG;AACN,YAAM,gBAAgB;AAAA,QACpB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,KAAK,aAAa,KAAK,UAAU,eAAe,GAAG;AACrD,YAAI,WAAW,SAAS,WAAW;AACjC,eAAK,kBAAkB,aAAa;AAAA,QACtC,OAAO;AACL,eAAK,UAAU,KAAK,OAAO;AAC3B,uBAAa,OAAO;AACpB,kBAAQ,MAAM;AAAA,QAChB;AAAA,MACF,OAAO;AACL,aAAK,aAAa,KAAK,aAAa;AAAA,MACtC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,eAAe;AAC/B,UAAM,EAAE,SAAS,SAAS,QAAQ,QAAQ,IAAI;AAC9C,UAAM,iBAAiB,CAAC,UAAU;AAChC,UAAI;AACF,cAAM,WAAW,KAAK,MAAM,MAAM,IAAI;AACtC,YAAI,SAAS,SAAS,eAAe,SAAS,QAAQ,YAAY,KAAK,aAAa;AAClF,uBAAa,OAAO;AACpB,eAAK,UAAU,oBAAoB,WAAW,cAAc;AAC5D,kBAAQ,SAAS,QAAQ,SAAS;AAAA,QACpC,WAAW,SAAS,SAAS,SAAS;AACpC,uBAAa,OAAO;AACpB,eAAK,UAAU,oBAAoB,WAAW,cAAc;AAC5D,iBAAO,IAAI,mBAAmB,iBAAiB,SAAS,QAAQ,KAAK,EAAE,CAAC;AAAA,QAC1E;AAAA,MACF,SAAS,KAAK;AAAA,MACd;AAAA,IACF;AACA,UAAM,kBAAkB;AACxB,UAAM,iBAAiB,WAAW,MAAM;AACtC,UAAI,KAAK,WAAW;AAClB,aAAK,UAAU,oBAAoB,WAAW,cAAc;AAAA,MAC9D;AACA,aAAO,IAAI,mBAAmB,gDAAgD,CAAC;AAAA,IACjF,GAAG,GAAG;AACN,kBAAc,UAAU;AACxB,iBAAa,eAAe;AAC5B,SAAK,UAAU,iBAAiB,WAAW,cAAc;AACzD,SAAK,UAAU,KAAK,OAAO;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAIA,oBAAoB;AAClB,QAAI,CAAC,KAAK,aAAa,KAAK,UAAU,eAAe,GAAG;AACtD;AAAA,IACF;AACA,UAAM,QAAQ,CAAC,GAAG,KAAK,YAAY;AACnC,SAAK,eAAe,CAAC;AACrB,UAAM,QAAQ,CAAC,kBAAkB;AAC/B,UAAI;AACF,cAAM,aAAa,KAAK,MAAM,cAAc,OAAO;AACnD,YAAI,WAAW,SAAS,WAAW;AACjC,eAAK,kBAAkB,aAAa;AAAA,QACtC,OAAO;AACL,eAAK,UAAU,KAAK,cAAc,OAAO;AACzC,uBAAa,cAAc,OAAO;AAClC,wBAAc,QAAQ,MAAM;AAAA,QAC9B;AAAA,MACF,SAAS,OAAO;AACd,qBAAa,cAAc,OAAO;AAClC,sBAAc,OAAO,IAAI,mBAAmB,+BAA+B,CAAC;AAAA,MAC9E;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EACA,MAAM,mBAAmB;AACvB,QAAI,KAAK,aAAa,KAAK,UAAU,eAAe,GAAG;AACrD,WAAK,cAAc;AACnB;AAAA,IACF;AACA,QAAI,KAAK,cAAc;AACrB,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,cAAM,kBAAkB,MAAM;AAC5B,cAAI,KAAK,aAAa;AACpB,oBAAQ;AAAA,UACV,WAAW,CAAC,KAAK,cAAc;AAC7B,mBAAO,IAAI,mBAAmB,mBAAmB,CAAC;AAAA,UACpD,OAAO;AACL,uBAAW,iBAAiB,GAAG;AAAA,UACjC;AAAA,QACF;AACA,wBAAgB;AAAA,MAClB,CAAC;AAAA,IACH;AACA,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI;AACF,cAAM,aAAa,KAAK;AACxB,cAAM,UAAU,WAAW,WAAW;AACtC,cAAM,UAAU,QAAQ,QAAQ,YAAY,QAAQ,EAAE,QAAQ,WAAW,OAAO;AAChF,cAAM,QAAQ,GAAG,OAAO,eAAe,KAAK,SAAS;AACrD,gBAAQ,IAAI,0CAAiD,KAAK,EAAE;AACpE,cAAM,UAAU,kBAAkB;AAClC,aAAK,YAAY,IAAI,QAAQ,KAAK;AAClC,YAAI,CAAC,KAAK,WAAW;AACnB,eAAK,eAAe;AACpB,iBAAO,IAAI,mBAAmB,qCAAqC,CAAC;AACpE;AAAA,QACF;AACA,aAAK,UAAU,SAAS,MAAM;AAC5B,kBAAQ,IAAI,wCAA+C,KAAK,SAAS,EAAE;AAC3E,eAAK,eAAe;AACpB,eAAK,cAAc;AACnB,eAAK,oBAAoB;AACzB,eAAK,kBAAkB;AACvB,kBAAQ;AAAA,QACV;AACA,aAAK,UAAU,YAAY,CAAC,UAAU;AACpC,cAAI;AACF,kBAAM,UAAU,KAAK,MAAM,MAAM,IAAI;AACrC,iBAAK,uBAAuB,OAAO;AAAA,UACrC,SAAS,OAAO;AACd,oBAAQ,MAAM,sCAAsC,KAAK;AAAA,UAC3D;AAAA,QACF;AACA,aAAK,UAAU,UAAU,MAAM;AAC7B,kBAAQ,IAAI,6CAAoD,KAAK,SAAS,EAAE;AAChF,eAAK,eAAe;AACpB,eAAK,cAAc;AACnB,eAAK,eAAe;AACpB,eAAK,qBAAqB,IAAI,mBAAmB,6BAA6B,CAAC;AAC/E,cAAI,KAAK,qBAAqB;AAC5B,yBAAa,KAAK,oBAAoB,OAAO;AAC7C,iBAAK,oBAAoB,OAAO,IAAI,mBAAmB,uCAAuC,CAAC;AAC/F,iBAAK,sBAAsB;AAAA,UAC7B;AACA,eAAK,kBAAkB;AAAA,QACzB;AACA,aAAK,UAAU,UAAU,CAAC,UAAU;AAClC,kBAAQ,MAAM,oBAAoB,KAAK;AACvC,kBAAQ,MAAM,sBAAsB,KAAK;AACzC,kBAAQ,MAAM,yBAAyB,KAAK,WAAW,UAAU;AACjE,eAAK,eAAe;AACpB,eAAK,cAAc;AACnB,iBAAO,IAAI,mBAAmB,kCAAkC,KAAK,EAAE,CAAC;AAAA,QAC1E;AACA,mBAAW,MAAM;AACf,cAAI,KAAK,WAAW,eAAe,GAAG;AACpC,iBAAK,eAAe;AACpB,mBAAO,IAAI,mBAAmB,8BAA8B,CAAC;AAAA,UAC/D;AAAA,QACF,GAAG,GAAG;AAAA,MACR,SAAS,OAAO;AACd,aAAK,eAAe;AACpB,eAAO,IAAI,mBAAmB,0CAA0C,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE,CAAC;AAAA,MACrI;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqB,OAAO;AAC1B,UAAM,QAAQ,CAAC,GAAG,KAAK,YAAY;AACnC,SAAK,eAAe,CAAC;AACrB,UAAM,QAAQ,CAAC,kBAAkB;AAC/B,mBAAa,cAAc,OAAO;AAClC,oBAAc,OAAO,KAAK;AAAA,IAC5B,CAAC;AAAA,EACH;AAAA,EACA,uBAAuB,SAAS;AAC9B,YAAQ,QAAQ,MAAM;AAAA,MACpB,KAAK;AACH,aAAK,iBAAiB,QAAQ,CAAC,aAAa;AAC1C,cAAI;AACF,qBAAS,QAAQ,OAAO;AAAA,UAC1B,SAAS,OAAO;AACd,oBAAQ,MAAM,8BAA8B,KAAK;AAAA,UACnD;AAAA,QACF,CAAC;AACD;AAAA,MACF,KAAK;AACH,aAAK,kBAAkB,QAAQ,CAAC,aAAa;AAC3C,cAAI;AACF,kBAAM,QAAQ,QAAQ,QAAQ,MAAM,SAAS,CAAC;AAC9C,qBAAS,KAAK;AAAA,UAChB,SAAS,OAAO;AACd,oBAAQ,MAAM,+BAA+B,KAAK;AAAA,UACpD;AAAA,QACF,CAAC;AACD;AAAA,MACF,KAAK;AACH,gBAAQ,IAAI,4BAAiC,QAAQ,QAAQ,OAAO,EAAE;AACtE,YAAI,KAAK,uBAAuB,QAAQ,QAAQ,YAAY,KAAK,aAAa;AAC5E,eAAK,oBAAoB,QAAQ;AAAA,QACnC;AACA;AAAA,MACF,KAAK;AACH,gBAAQ,IAAI,gCAAqC,QAAQ,QAAQ,OAAO,EAAE;AAC1E;AAAA,MACF,KAAK;AACH;AAAA,MACF,KAAK;AACH;AAAA,MACF,KAAK;AACH,gBAAQ,MAAM,mBAAmB,QAAQ,QAAQ,KAAK;AACtD,YAAI,KAAK,uBAAuB,QAAQ,QAAQ,YAAY,KAAK,aAAa;AAC5E,eAAK,oBAAoB,OAAO,IAAI,mBAAmB,uBAAuB,QAAQ,QAAQ,KAAK,EAAE,CAAC;AAAA,QACxG;AACA;AAAA,MACF;AACE,gBAAQ,IAAI,yBAAyB,QAAQ,IAAI;AAAA,IACrD;AAAA,EACF;AAAA,EACA,iBAAiB;AACf,QAAI,KAAK,gBAAgB;AACvB,oBAAc,KAAK,cAAc;AAAA,IACnC;AACA,SAAK,iBAAiB,WAAW,YAAY,MAAM;AACjD,UAAI,KAAK,aAAa,KAAK,UAAU,eAAe,GAAG;AACrD,aAAK,UAAU,KAAK,KAAK,UAAU,EAAE,MAAM,QAAQ,SAAS,CAAC,EAAE,CAAC,CAAC;AAAA,MACnE;AAAA,IACF,GAAG,IAAI;AAAA,EACT;AAAA,EACA,oBAAoB;AAClB,QAAI,KAAK,gBAAgB;AACvB,mBAAa,KAAK,cAAc;AAAA,IAClC;AACA,QAAI,CAAC,KAAK,gBAAgB,CAAC,KAAK,qBAAqB;AACnD;AAAA,IACF;AACA,SAAK;AACL,UAAM,YAAY,KAAK,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,iBAAiB,IAAI,GAAG;AACzE,UAAM,SAAS,KAAK,OAAO,IAAI;AAC/B,UAAM,QAAQ,YAAY;AAC1B,YAAQ,IAAI,mCAA0C,KAAK,iBAAiB,OAAO,KAAK,MAAM,KAAK,CAAC,IAAI;AACxG,SAAK,iBAAiB,WAAW,WAAW,YAAY;AACtD,UAAI,KAAK,gBAAgB,KAAK,qBAAqB;AACjD,YAAI;AACF,gBAAM,KAAK,iBAAiB;AAC5B,cAAI,KAAK,gBAAgB,KAAK,WAAW;AACvC,kBAAM,mBAAmB;AAAA,cACvB,MAAM;AAAA,cACN,SAAS;AAAA,gBACP,SAAS,KAAK;AAAA,cAChB;AAAA,YACF;AACA,iBAAK,UAAU,KAAK,KAAK,UAAU,gBAAgB,CAAC;AACpD,iBAAK,eAAe;AAAA,UACtB;AAAA,QACF,SAAS,OAAO;AACd,kBAAQ,MAAM,wBAAwB,KAAK;AAC3C,eAAK,kBAAkB;AAAA,QACzB;AAAA,MACF;AAAA,IACF,GAAG,KAAK;AAAA,EACV;AAAA,EACA,UAAU;AACR,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,eAAe;AACpB,QAAI,KAAK,qBAAqB;AAC5B,mBAAa,KAAK,oBAAoB,OAAO;AAC7C,WAAK,oBAAoB,OAAO,IAAI,mBAAmB,iBAAiB,CAAC;AACzE,WAAK,sBAAsB;AAAA,IAC7B;AACA,SAAK,qBAAqB,IAAI,mBAAmB,iBAAiB,CAAC;AACnE,QAAI,KAAK,gBAAgB;AACvB,oBAAc,KAAK,cAAc;AACjC,WAAK,iBAAiB;AAAA,IACxB;AACA,QAAI,KAAK,gBAAgB;AACvB,mBAAa,KAAK,cAAc;AAChC,WAAK,iBAAiB;AAAA,IACxB;AACA,QAAI,KAAK,WAAW;AAClB,WAAK,UAAU,MAAM;AACrB,WAAK,YAAY;AAAA,IACnB;AACA,SAAK,mBAAmB,CAAC;AACzB,SAAK,oBAAoB,CAAC;AAAA,EAC5B;AACF;AACA,IAAI,oBAAoB,MAAM;AAAA,EAC5B,YAAY,YAAY,WAAW;AACjC,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA,EACnB;AAAA,EACA,WAA2B,oBAAI,IAAI;AAAA,EACnC,WAAW,CAAC;AAAA,EACZ,QAAQ,MAAM;AACZ,QAAI,CAAC,KAAK,SAAS,IAAI,IAAI,GAAG;AAC5B,WAAK,SAAS,IAAI,MAAM,IAAI,qBAAqB,MAAM,KAAK,YAAY,KAAK,SAAS,CAAC;AAAA,IACzF;AACA,WAAO,KAAK,SAAS,IAAI,IAAI;AAAA,EAC/B;AAAA,EACA,MAAM,UAAU,aAAa,UAAU,UAAU,CAAC,GAAG;AACnD,UAAM,UAAU,KAAK,QAAQ,WAAW;AACxC,UAAM,QAAQ,UAAU,OAAO;AAC/B,UAAM,QAAQ,KAAK,SAAS,WAAW,MAAM;AAAA,MAC3C,aAA6B,oBAAI,IAAI;AAAA,MACrC,cAA8B,oBAAI,IAAI;AAAA,MACtC,YAAY;AAAA,IACd;AACA,UAAM,YAAY,IAAI,QAAQ;AAC9B,UAAM,eAAe,QAAQ,UAAU,QAAQ;AAC/C,WAAO,MAAM;AACX,mBAAa;AACb,YAAM,YAAY,OAAO,QAAQ;AACjC,UAAI,MAAM,YAAY,SAAS,KAAK,MAAM,aAAa,SAAS,GAAG;AACjE,gBAAQ,YAAY;AACpB,eAAO,KAAK,SAAS,WAAW;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,QAAQ,aAAa,MAAM,MAAM,UAAU,CAAC,GAAG;AACnD,UAAM,UAAU,KAAK,QAAQ,WAAW;AACxC,WAAO,QAAQ,QAAQ,MAAM,MAAM,OAAO;AAAA,EAC5C;AAAA,EACA,MAAM,SAAS,aAAa;AAC1B,UAAM,UAAU,KAAK,QAAQ,WAAW;AACxC,WAAO,QAAQ,YAAY;AAAA,EAC7B;AAAA,EACA,WAAW,aAAa,UAAU;AAChC,UAAM,UAAU,KAAK,QAAQ,WAAW;AACxC,UAAM,QAAQ,KAAK,SAAS,WAAW,MAAM;AAAA,MAC3C,aAA6B,oBAAI,IAAI;AAAA,MACrC,cAA8B,oBAAI,IAAI;AAAA,MACtC,YAAY;AAAA,IACd;AACA,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,gBAAgB,QAAQ,WAAW,QAAQ;AACjD,WAAO,MAAM;AACX,oBAAc;AACd,YAAM,aAAa,OAAO,QAAQ;AAClC,UAAI,MAAM,YAAY,SAAS,KAAK,MAAM,aAAa,SAAS,GAAG;AACjE,gBAAQ,YAAY;AACpB,eAAO,KAAK,SAAS,WAAW;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AACF;AAGA,IAAI,yBAAyB,MAAM;AAAA,EACjC,YAAY,YAAY;AACtB,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2CA,MAAM,MAAM,QAAQ;AAClB,QAAI;AACF,UAAI,CAAC,OAAO,MAAM,CAAC,OAAO,WAAW,CAAC,OAAO,QAAQ,CAAC,OAAO,MAAM;AACjE,cAAM,IAAI,wBAAwB,uEAAuE;AAAA,MAC3G;AACA,YAAM,WAAW,MAAM,KAAK,WAAW,KAAK,sBAAsB,KAAK,WAAW,SAAS,UAAU,MAAM;AAC3G,UAAI,CAAC,SAAS,QAAQ,OAAO,SAAS,KAAK,YAAY,WAAW;AAChE,cAAM,IAAI,wBAAwB,iCAAiC;AAAA,MACrE;AACA,aAAO,SAAS;AAAA,IAClB,SAAS,OAAO;AACd,UAAI,iBAAiB,yBAAyB;AAC5C,cAAM;AAAA,MACR;AACA,YAAM,eAAe,MAAM,UAAU,MAAM,OAAO,WAAW,MAAM,WAAW;AAC9E,YAAM,IAAI,wBAAwB,yBAAyB,YAAY,IAAI,MAAM,UAAU,QAAQ,MAAM,UAAU,MAAM,KAAK;AAAA,IAChI;AAAA,EACF;AACF;AAGA,IAAI,mBAAmB,KAAK,KAAK;AACjC,IAAI,iBAAiB;AACrB,IAAI,gBAAgB;AACpB,IAAI,oBAAoB;AACxB,IAAI,qBAAqB,MAAM;AAAA,EAC7B;AAAA,EACA;AAAA,EACA,QAAQ,CAAC;AAAA,EACT,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,qBAAqB;AAAA,EACrB,YAAY,CAAC;AAAA,EACb,uBAAuB,CAAC;AAAA,EACxB,YAAY,YAAY,WAAW;AACjC,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,QAAI,OAAO,WAAW,aAAa;AACjC;AAAA,IACF;AACA,QAAI,UAAU,eAAe,KAAK;AAChC,WAAK,UAAU;AACf;AAAA,IACF;AACA,SAAK,yBAAyB;AAC9B,SAAK,iBAAiB;AACtB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,yBAAyB;AAC9B,SAAK,oBAAoB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,QAAQ;AACpB,WAAO,iBAAiB,MAAM,IAAI,KAAK,SAAS;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW,OAAO,CAAC,GAAG;AACxB,QAAI,CAAC,KAAK,WAAW,OAAO,WAAW,aAAa;AAClD;AAAA,IACF;AACA,UAAM,QAAQ,KAAK,WAAW,WAAW,IAAI;AAC7C,SAAK,QAAQ,KAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,SAAK,UAAU;AACf,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,SAAK,QAAQ;AACb,QAAI,OAAO,WAAW,aAAa;AACjC,aAAO,2BAA2B,OAAO,IAAI;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AACP,SAAK,UAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,QAAQ;AAChB,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,OAAO;AAClB,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACjB,SAAK,uBAAuB,CAAC;AAC7B,QAAI;AACF,mBAAa,WAAW,KAAK,cAAc,aAAa,CAAC;AAAA,IAC3D,QAAQ;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAEA,WAAW,MAAM,OAAO,CAAC,GAAG;AAC1B,UAAM,YAAY,KAAK,qBAAqB;AAC5C,UAAM,UAAU,KAAK,cAAc;AACnC,WAAO;AAAA,MACL;AAAA,MACA,YAA4B,oBAAI,KAAK,GAAG,YAAY;AAAA,MACpD,YAAY,KAAK;AAAA,MACjB,SAAS,KAAK;AAAA,MACd,YAAY,KAAK;AAAA,MACjB,YAAY;AAAA,MACZ,UAAU,OAAO,SAAS;AAAA,MAC1B,UAAU,SAAS,YAAY;AAAA,MAC/B,cAAc,OAAO;AAAA,MACrB;AAAA,MACA,YAAY,KAAK,UAAU,cAAc,KAAK,qBAAqB,cAAc;AAAA,MACjF,YAAY,KAAK,UAAU,cAAc,KAAK,qBAAqB,cAAc;AAAA,MACjF,cAAc,KAAK,UAAU,gBAAgB,KAAK,qBAAqB,gBAAgB;AAAA,MACvF,aAAa,KAAK,UAAU,eAAe,KAAK,qBAAqB,eAAe;AAAA,MACpF,UAAU,KAAK,UAAU,YAAY,KAAK,qBAAqB,YAAY;AAAA,MAC3E,GAAG,KAAK,aAAa,IAAI;AAAA,IAC3B;AAAA,EACF;AAAA,EACA,aAAa,MAAM;AACjB,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,KAAK,SAAS,oBAAoB,KAAK,MAAM,GAAG,oBAAoB,CAAC,IAAI,QAAQ;AAAA,IAC1F;AACA,QAAI,OAAO,SAAS,YAAY,SAAS,MAAM;AAC7C,YAAM,SAAS,CAAC;AAChB,iBAAW,OAAO,MAAM;AACtB,eAAO,GAAG,IAAI,KAAK,aAAa,KAAK,GAAG,CAAC;AAAA,MAC3C;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EACA,QAAQ,OAAO;AACb,SAAK,MAAM,KAAK,KAAK;AACrB,SAAK,aAAa;AAClB,QAAI,KAAK,MAAM,UAAU,gBAAgB;AACvC,WAAK,MAAM;AAAA,IACb,WAAW,CAAC,KAAK,OAAO;AACtB,WAAK,QAAQ,WAAW,MAAM,KAAK,MAAM,GAAG,aAAa;AAAA,IAC3D;AAAA,EACF;AAAA,EACA,MAAM,QAAQ;AACZ,SAAK,WAAW;AAChB,QAAI,KAAK,MAAM,WAAW,GAAG;AAC3B;AAAA,IACF;AACA,UAAM,SAAS,KAAK,MAAM,MAAM,GAAG,cAAc;AACjD,SAAK,QAAQ,KAAK,MAAM,MAAM,cAAc;AAC5C,SAAK,aAAa;AAClB,QAAI;AACF,YAAM,KAAK,WAAW,KAAK,kBAAkB,KAAK,SAAS,QAAQ,EAAE,OAAO,CAAC;AAAA,IAC/E,SAAS,OAAO;AACd,WAAK,QAAQ,CAAC,GAAG,QAAQ,GAAG,KAAK,KAAK;AACtC,WAAK,aAAa;AAClB,cAAQ,MAAM,oCAAoC,KAAK;AAAA,IACzD;AACA,QAAI,KAAK,MAAM,SAAS,GAAG;AACzB,WAAK,QAAQ,WAAW,MAAM,KAAK,MAAM,GAAG,aAAa;AAAA,IAC3D;AAAA,EACF;AAAA,EACA,aAAa;AACX,QAAI,KAAK,OAAO;AACd,mBAAa,KAAK,KAAK;AACvB,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA,EACA,uBAAuB;AACrB,QAAI;AACF,YAAM,SAAS,aAAa,QAAQ,KAAK,cAAc,SAAS,CAAC;AACjE,UAAI,QAAQ;AACV,cAAM,UAAU,KAAK,MAAM,MAAM;AACjC,cAAM,MAAM,KAAK,IAAI;AACrB,YAAI,MAAM,QAAQ,iBAAiB,kBAAkB;AACnD,iBAAO,KAAK,iBAAiB;AAAA,QAC/B;AACA,gBAAQ,iBAAiB;AACzB,qBAAa,QAAQ,KAAK,cAAc,SAAS,GAAG,KAAK,UAAU,OAAO,CAAC;AAC3E,eAAO,QAAQ;AAAA,MACjB;AACA,aAAO,KAAK,iBAAiB;AAAA,IAC/B,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EACA,mBAAmB;AACjB,UAAM,MAAM,KAAK,IAAI;AACrB,UAAM,WAAW,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AAC3D,UAAM,UAAU;AAAA,MACd,IAAI,QAAQ,GAAG,IAAI,QAAQ;AAAA,MAC3B,WAAW;AAAA,MACX,gBAAgB;AAAA,IAClB;AACA,QAAI;AACF,mBAAa,QAAQ,KAAK,cAAc,SAAS,GAAG,KAAK,UAAU,OAAO,CAAC;AAAA,IAC7E,QAAQ;AAAA,IACR;AACA,WAAO,QAAQ;AAAA,EACjB;AAAA,EACA,YAAY;AACV,QAAI;AACF,YAAM,SAAS,aAAa,QAAQ,KAAK,cAAc,OAAO,CAAC;AAC/D,UAAI,QAAQ;AACV,aAAK,QAAQ,KAAK,MAAM,MAAM;AAC9B,YAAI,KAAK,MAAM,SAAS,GAAG;AACzB,eAAK,QAAQ,WAAW,MAAM,KAAK,MAAM,GAAG,aAAa;AAAA,QAC3D;AAAA,MACF;AAAA,IACF,QAAQ;AACN,WAAK,QAAQ,CAAC;AAAA,IAChB;AAAA,EACF;AAAA,EACA,eAAe;AACb,QAAI;AACF,UAAI,KAAK,MAAM,WAAW,GAAG;AAC3B,qBAAa,WAAW,KAAK,cAAc,OAAO,CAAC;AAAA,MACrD,OAAO;AACL,qBAAa,QAAQ,KAAK,cAAc,OAAO,GAAG,KAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MAC9E;AAAA,IACF,QAAQ;AAAA,IACR;AAAA,EACF;AAAA,EACA,gBAAgB;AACd,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,IAAI,UAAU;AACnB,WAAK,qBAAqB;AAAA,IAC5B;AAAA,EACF;AAAA,EACA,2BAA2B;AACzB,QAAI,CAAC,OAAO,uBAAuB;AACjC,YAAM,oBAAoB,QAAQ;AAClC,YAAM,uBAAuB,QAAQ;AACrC,YAAM,qBAAqC,oBAAI,IAAI;AACnD,aAAO,4BAA4B;AACnC,cAAQ,YAAY,IAAI,SAAS;AAC/B,0BAAkB,MAAM,SAAS,IAAI;AACrC,2BAAmB,QAAQ,CAAC,aAAa;AACvC,cAAI,SAAS,UAAU,GAAG;AACxB,qBAAS,IAAI,UAAU;AAAA,UACzB;AAAA,QACF,CAAC;AAAA,MACH;AACA,cAAQ,eAAe,IAAI,SAAS;AAClC,6BAAqB,MAAM,SAAS,IAAI;AACxC,2BAAmB,QAAQ,CAAC,aAAa;AACvC,cAAI,SAAS,UAAU,GAAG;AACxB,qBAAS,IAAI,UAAU;AAAA,UACzB;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO,iBAAiB,YAAY,MAAM;AACxC,2BAAmB,QAAQ,CAAC,aAAa;AACvC,cAAI,SAAS,UAAU,GAAG;AACxB,qBAAS,IAAI,UAAU;AAAA,UACzB;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AACD,aAAO,wBAAwB;AAAA,IACjC;AACA,WAAO,2BAA2B,IAAI,IAAI;AAAA,EAC5C;AAAA,EACA,sBAAsB;AACpB,WAAO,iBAAiB,YAAY,MAAM;AACxC,WAAK,MAAM;AAAA,IACb,CAAC;AACD,WAAO,iBAAiB,UAAU,MAAM;AACtC,WAAK,MAAM;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EACA,mBAAmB;AACjB,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,SAAK,YAAY;AAAA,MACf,YAAY,UAAU,IAAI,YAAY;AAAA,MACtC,YAAY,UAAU,IAAI,YAAY;AAAA,MACtC,cAAc,UAAU,IAAI,cAAc;AAAA,MAC1C,aAAa,UAAU,IAAI,aAAa;AAAA,MACxC,UAAU,UAAU,IAAI,UAAU;AAAA,IACpC;AACA,UAAM,eAAe,OAAO,OAAO,KAAK,SAAS,EAAE,KAAK,CAAC,MAAM,MAAM,IAAI;AACzE,QAAI,cAAc;AAChB,WAAK,mBAAmB;AAAA,IAC1B;AAAA,EACF;AAAA,EACA,2BAA2B;AACzB,QAAI;AACF,YAAM,SAAS,aAAa,QAAQ,KAAK,cAAc,aAAa,CAAC;AACrE,UAAI,QAAQ;AACV,aAAK,uBAAuB,KAAK,MAAM,MAAM;AAAA,MAC/C;AAAA,IACF,QAAQ;AACN,WAAK,uBAAuB,CAAC;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,qBAAqB;AACnB,QAAI;AACF,YAAM,cAAc;AAAA,QAClB,GAAG,KAAK;AAAA,QACR,GAAG,OAAO;AAAA,UACR,OAAO,QAAQ,KAAK,SAAS,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,MAAM,IAAI;AAAA,QAC9D;AAAA,MACF;AACA,mBAAa,QAAQ,KAAK,cAAc,aAAa,GAAG,KAAK,UAAU,WAAW,CAAC;AACnF,WAAK,uBAAuB;AAAA,IAC9B,QAAQ;AAAA,IACR;AAAA,EACF;AAAA,EACA,gBAAgB;AACd,UAAM,WAAW,SAAS;AAC1B,UAAM,YAAY,KAAK,UAAU;AACjC,SAAK,UAAU;AACf,QAAI,WAAW;AACb,UAAI,cAAc,SAAS,cAAc,MAAO,QAAO;AACvD,UAAI,cAAc,QAAS,QAAO;AAClC,UAAI,cAAc,SAAU,QAAO;AACnC,UAAI,cAAc,WAAY,QAAO;AACrC,UAAI,cAAc,UAAW,QAAO;AACpC,UAAI,cAAc,YAAa,QAAO;AAAA,IACxC;AACA,QAAI,CAAC,SAAU,QAAO;AACtB,QAAI;AACF,YAAM,cAAc,IAAI,IAAI,QAAQ;AACpC,YAAM,iBAAiB,YAAY,SAAS,YAAY;AACxD,UAAI,wDAAwD,KAAK,cAAc,GAAG;AAChF,eAAO;AAAA,MACT;AACA,UAAI,0EAA0E,KAAK,cAAc,GAAG;AAClG,eAAO;AAAA,MACT;AACA,UAAI,2BAA2B,KAAK,cAAc,GAAG;AACnD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,IAAI,kBAAkB,MAAM;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,QAAQ;AAClB,SAAK,OAAO,IAAI,UAAU,MAAM;AAChC,SAAK,aAAa,IAAI;AAAA,MACpB;AAAA,MACA,MAAM,KAAK,KAAK,SAAS;AAAA,MACzB,MAAM,KAAK,KAAK,cAAc;AAAA,IAChC;AACA,SAAK,KAAK,IAAI,cAAc,KAAK,UAAU;AAC3C,SAAK,UAAU,IAAI,iBAAiB,KAAK,UAAU;AACnD,SAAK,KAAK,IAAI,YAAY,KAAK,UAAU;AACzC,SAAK,OAAO,IAAI,cAAc,KAAK,YAAY,OAAO,SAAS;AAC/D,SAAK,WAAW,IAAI,kBAAkB,KAAK,YAAY,OAAO,SAAS;AACvE,SAAK,gBAAgB,IAAI,uBAAuB,KAAK,UAAU;AAC/D,SAAK,YAAY,IAAI,mBAAmB,KAAK,YAAY,OAAO,SAAS;AACzE,SAAK,KAAK,mBAAmB,CAAC,UAAU;AACtC,UAAI,MAAM,mBAAmB,MAAM,MAAM;AACvC,aAAK,UAAU,UAAU,MAAM,KAAK,EAAE;AACtC,aAAK,UAAU,aAAa,MAAM,KAAK,KAAK;AAAA,MAC9C,OAAO;AACL,aAAK,UAAU,UAAU,IAAI;AAC7B,aAAK,UAAU,aAAa,IAAI;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AACF;AACA,SAAS,aAAa,QAAQ;AAC5B,MAAI,CAAC,OAAO,WAAW;AACrB,UAAM,IAAI,MAAM,uBAAuB;AAAA,EACzC;AACA,SAAO,IAAI,gBAAgB,MAAM;AACnC;",
  "names": ["__require"]
}
